<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  
    
      
    

    
  

  

  

  

  
    
    
    <link href="https://fonts.loli.net/css?family=Noto Serif SC:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="这篇文章主要记录大二学期的平衡摩托车项目的预习工作">
<meta property="og:type" content="article">
<meta property="og:title" content="MotorCar_design_Prelearning">
<meta property="og:url" content="https://baikal2411.github.io/2023/12/09/MotorCar-design_Prelearning/index.html">
<meta property="og:site_name" content="Millimeter-wave IC Design Learning Road">
<meta property="og:description" content="这篇文章主要记录大二学期的平衡摩托车项目的预习工作">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2023-12-09T15:41:57.000Z">
<meta property="article:modified_time" content="2025-04-09T16:32:30.333Z">
<meta property="article:author" content="Liyuan Zha">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"hide","offset":12,"b2t":true,"scrollpercent":true,"onmobile":true},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://baikal2411.github.io/2023/12/09/MotorCar-design_Prelearning/"/>





  <title>MotorCar_design_Prelearning | Millimeter-wave IC Design Learning Road</title>
  








<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"><style>mjx-container[jax="SVG"] {
  direction: ltr;
}

mjx-container[jax="SVG"] > svg {
  overflow: visible;
}

mjx-container[jax="SVG"][display="true"] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax="SVG"][justify="left"] {
  text-align: left;
}

mjx-container[jax="SVG"][justify="right"] {
  text-align: right;
}

g[data-mml-node="merror"] > g {
  fill: red;
  stroke: red;
}

g[data-mml-node="merror"] > rect[data-background] {
  fill: yellow;
  stroke: none;
}

g[data-mml-node="mtable"] > line[data-line] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > rect[data-frame] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > .mjx-dashed {
  stroke-dasharray: 140;
}

g[data-mml-node="mtable"] > .mjx-dotted {
  stroke-linecap: round;
  stroke-dasharray: 0,140;
}

g[data-mml-node="mtable"] > svg {
  overflow: visible;
}

[jax="SVG"] mjx-tool {
  display: inline-block;
  position: relative;
  width: 0;
  height: 0;
}

[jax="SVG"] mjx-tool > mjx-tip {
  position: absolute;
  top: 0;
  left: 0;
}

mjx-tool > mjx-tip {
  display: inline-block;
  padding: .2em;
  border: 1px solid #888;
  font-size: 70%;
  background-color: #F8F8F8;
  color: black;
  box-shadow: 2px 2px 5px #AAAAAA;
}

g[data-mml-node="maction"][data-toggle] {
  cursor: pointer;
}

mjx-status {
  display: block;
  position: fixed;
  left: 1em;
  bottom: 1em;
  min-width: 25%;
  padding: .2em .4em;
  border: 1px solid #888;
  font-size: 90%;
  background-color: #F8F8F8;
  color: black;
}

foreignObject[data-mjx-xml] {
  font-family: initial;
  line-height: normal;
  overflow: visible;
}

.MathJax path {
  stroke-width: 3;
}

mjx-container[display="true"] {
  overflow: auto hidden;
}

mjx-container[display="true"] + br {
  display: none;
}
</style></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Millimeter-wave IC Design Learning Road</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">劝君莫惜金缕衣，劝君须取少年时。</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            Search
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="Searching..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://baikal2411.github.io/2023/12/09/MotorCar-design_Prelearning/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/header.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Millimeter-wave IC Design Learning Road">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">MotorCar_design_Prelearning</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2023-12-09T23:41:57+08:00">
                2023-12-09
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  10.2k 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">预估阅读时间 &asymp;</span>
                
                <span title="预估阅读时间">
                  45 分钟
                </span>
              
            </div>
          

          
              <div class="post-description">
                  这篇文章主要记录大二学期的平衡摩托车项目的预习工作
              </div>
          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <span id="more"></span>
<p>在不侧重于硬件配置情况下，给出逐飞给出的部分外设重要函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//zf_common_clock.c：设置、获取系统频率，关闭看门狗，时钟初始化，等待所有核心初始化完毕</span></span><br><span class="line">*****************************************************************************************</span><br><span class="line"><span class="comment">//zf_device_absolute.encoder.c:编码器部分：</span></span><br><span class="line">uint8 <span class="title function_">absolute_encoder_init</span><span class="params">()</span>;         <span class="comment">//绝对值编码器初始化</span></span><br><span class="line">int16 <span class="title function_">absolute_encoder_get_offset</span><span class="params">()</span>;   <span class="comment">//绝对值编码器获取相较上次位置的偏移值</span></span><br><span class="line">int16 <span class="title function_">absolute_encoder_get_location</span><span class="params">()</span>; <span class="comment">//绝对值编码器获取当前角度值</span></span><br><span class="line">****************************************************************************************</span><br><span class="line"><span class="comment">//zf_device_bluetooth_ch9141.c: 蓝牙转串口模块</span></span><br><span class="line">uint32 <span class="title function_">bluetooth_ch9141_send_byte</span><span class="params">(<span class="type">const</span> uint8 data)</span>;   <span class="comment">//蓝牙转串口模块 发送数据</span></span><br><span class="line">uint32 <span class="title function_">bluetooth_ch9141_send_buffer</span><span class="params">(<span class="type">const</span> uint8 *buff, uint32 len)</span>; <span class="comment">//蓝牙转串口模块 发送数组</span></span><br><span class="line">uint32 <span class="title function_">bluetooth_ch9141_send_string</span> <span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span>; <span class="comment">//蓝牙转串口模块 发送字符串</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">bluetooth_ch9141_send_image</span> <span class="params">(<span class="type">const</span> uint8 *image_addr, uint32 image_size)</span>;</span><br><span class="line"><span class="comment">//蓝牙转串口模块 发送摄像头图像至上位机查看图像</span></span><br><span class="line">uint32 <span class="title function_">bluetooth_ch9141_read_buffer</span> <span class="params">(uint8 *buff, uint32 len)</span>;<span class="comment">//蓝牙转串口模块 读取函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">bluetooth_ch9141_uart_callback</span> <span class="params">(<span class="type">void</span>)</span>; <span class="comment">//蓝牙转串口模块 串口中断回调函数</span></span><br><span class="line">uint8 <span class="title function_">bluetooth_ch9141_init</span> <span class="params">(<span class="type">void</span>)</span><span class="comment">// 蓝牙转串口模块 初始化；使用的波特率为115200 为蓝牙转串口模块的默认波特率 如需其他波特率请使用上位机修改模块参数 *****************************************************************************************</span></span><br><span class="line"><span class="comment">//zf_device_imu660ra.c: IMU660ra模块</span></span><br><span class="line">uint8 <span class="title function_">imu660ra_init</span> <span class="params">(<span class="type">void</span>)</span>; <span class="comment">//初始化 IMU660RA</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">imu660ra_get_acc</span> <span class="params">(<span class="type">void</span>)</span>; <span class="comment">//获取 IMU660RA 加速度计数据imu660ra_acc_x/y/z</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">imu660ra_get_gyro</span> <span class="params">(<span class="type">void</span>)</span>; <span class="comment">//获取 IMU660RA 陀螺仪数据imu660ra_gyro_x/y/z</span></span><br><span class="line"><span class="comment">//还有imu963ra,mpu6050的配置代码，结构与IMU660ra相似</span></span><br><span class="line">**********************************************************************************</span><br><span class="line"><span class="comment">//zf_device_ips200.c: 屏幕显示</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ips200_clear</span> <span class="params">(<span class="type">void</span>)</span>； <span class="comment">//IPS200 清屏函数，将屏幕清空成背景颜色</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ips200_full</span> <span class="params">(<span class="type">const</span> uint16 color)</span>；<span class="comment">//IPS200 屏幕填充函数，颜色格式 RGB565 或者可以使用 zf_common_font.h 内 rgb565_color_enum 枚举值或者自行写入</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ips200_set_dir</span> <span class="params">(ips200_dir_enum dir)</span>；<span class="comment">//设置显示方向，只有在初始化屏幕之前调用才生效</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ips200_set_font</span> <span class="params">(ips200_font_size_enum font)</span>；<span class="comment">//设置显示字体</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ips200_set_color</span> <span class="params">(<span class="type">const</span> uint16 pen, <span class="type">const</span> uint16 bgcolor)</span>；<span class="comment">//设置显示颜色</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ips200_draw_point</span> <span class="params">(uint16 x, uint16 y, <span class="type">const</span> uint16 color)</span>；<span class="comment">//IPS200 画点</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ips200_draw_line</span> <span class="params">(uint16 x_start, uint16 y_start, uint16 x_end, uint16 y_end, <span class="type">const</span> uint16 color)</span>；<span class="comment">//画线</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ips200_show_char</span> <span class="params">(uint16 x, uint16 y, <span class="type">const</span> <span class="type">char</span> dat)</span>；<span class="comment">//显示字符</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ips200_show_string</span> <span class="params">(uint16 x, uint16 y, <span class="type">const</span> <span class="type">char</span> dat[])</span>；<span class="comment">//IPS200 显示字符串</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ips200_show_int</span> <span class="params">(uint16 x, uint16 y, <span class="type">const</span> int32 dat, uint8 num)</span>;<span class="comment">//IPS200 显示32位有符号 (去除整数部分无效的0)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ips200_show_uint</span> <span class="params">(uint16 x, uint16 y, <span class="type">const</span> uint32 dat, uint8 num)</span>;<span class="comment">//IPS200 显示32位无符号 (去除整数部分无效的0)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ips200_show_float</span> <span class="params">(uint16 x, uint16 y, <span class="type">const</span> <span class="type">double</span> dat, uint8 num, uint8 pointnum)</span></span><br><span class="line"><span class="comment">//IPS200 显示浮点数(去除整数部分无效的0)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ips200_show_binary_image</span> <span class="params">(uint16 x, uint16 y, <span class="type">const</span> uint8 *image, uint16 width, uint16 height, uint16 dis_width, uint16 dis_height)</span>;<span class="comment">//IPS200 显示二值图像 数据每八个点组成一个字节数据,不可以用来直接显示总钻风的未压缩的二值化图像    </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ips200_show_gray_image</span> <span class="params">(uint16 x, uint16 y, <span class="type">const</span> uint8 *image, uint16 width, uint16 height, uint16 dis_width, uint16 dis_height, uint8 threshold)</span>;<span class="comment">//IPS200 显示 8bit 灰度图像 带二值化阈值,如果要显示二值化图像 直接修改最后一个参数为需要的二值化阈值即可</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ips200_show_rgb565_image</span> <span class="params">(uint16 x, uint16 y, <span class="type">const</span> uint16 *image, uint16 width, uint16 height, uint16 dis_width, uint16 dis_height, uint8 color_mode)</span>;<span class="comment">//IPS200 显示 RGB565 彩色图像,用于显示凌瞳的 RGB565 的图像,如果要显示低位在前的其他 RGB565 图像 修改最后一个参数即可</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ips200_show_wave</span> <span class="params">(uint16 x, uint16 y, <span class="type">const</span> uint16 *wave, uint16 width, uint16 value_max, uint16 dis_width, uint16 dis_value_max)</span>;<span class="comment">//IPS200 显示波形</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ips200_show_chinese</span> <span class="params">(uint16 x, uint16 y, uint8 size, <span class="type">const</span> uint8 *chinese_buffer, uint8 number, <span class="type">const</span> uint16 color)</span>;<span class="comment">//汉字显示</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ips200_init</span> <span class="params">(ips200_type_enum type_select)</span>;<span class="comment">//  2寸 IPS液晶初始化   </span></span><br><span class="line"><span class="comment">//IPS114，oled,tft180同理。</span></span><br><span class="line">**********************************************************************************</span><br><span class="line"><span class="comment">//zf_device_key.c:按键状态扫描; 获取按键状态; 清除指定按键状态;按键初始化</span></span><br><span class="line">**********************************************************************************</span><br><span class="line"><span class="comment">//zf_device_mt9v03x.c:</span></span><br><span class="line"><span class="comment">//定义 MT9V03X 基本配置,初始化    </span></span><br><span class="line"><span class="comment">//注：小钻风摄像头OV7725以及scc8660同理</span></span><br><span class="line">**********************************************************************************    </span><br></pre></td></tr></table></figure>
<p>例程中的重要部分：</p>
<table>
<colgroup>
<col style="width: 23%">
<col style="width: 76%">
</colgroup>
<thead>
<tr>
<th>GPIO演示例程</th>
<th>本例程主要作用是，展示如何使用GPIO模块</th>
</tr>
</thead>
<tbody>
<tr>
<td>串口演示例程</td>
<td>本例程主要作用是，展示如何使用串口的发送与中断接收</td>
</tr>
<tr>
<td>ADC采集例程</td>
<td>本例程主要作用是，展示如何使用ADC模块</td>
</tr>
<tr>
<td>PWM输出例程</td>
<td>本例程主要作用是，展示如何使用GTM模块输出PWM以及设定占空比</td>
</tr>
<tr>
<td>周期中断演示例程</td>
<td>本例程主要作用是，展示如何使用定时器完成周期中断</td>
</tr>
<tr>
<td>GPIO中断演示例程</td>
<td>本例程主要作用是，展示如何使用GPIO触发中断</td>
</tr>
<tr>
<td>编码器例程</td>
<td>本例程主要作用是，展示如何使用正交解码编码器以及带方向编码器</td>
</tr>
<tr>
<td>Flash存取例程</td>
<td>本例程主要作用是，展示如何使用片内EEPROM(Dflash)存取参数</td>
</tr>
<tr>
<td>延时例程</td>
<td>本例程主要作用是，展示如何使用滴答定时器进行延时</td>
</tr>
<tr>
<td>调试信息输出例程</td>
<td>本例程主要作用是，展示如何使用底层库进行调试信息输出</td>
</tr>
<tr>
<td>中断优先级例程</td>
<td>本例程主要作用是，展示如何使用中断优先级的设置</td>
</tr>
<tr>
<td>核心1处理中断例程</td>
<td>本例程主要作用是，展示如何使用核心1来处理中断</td>
</tr>
<tr>
<td>双核使用例程</td>
<td>本例程主要作用是，展示如何使用双核同时运行程序</td>
</tr>
<tr>
<td>指定变量或代码位置</td>
<td>本例程主要作用是，展示如何控制变量或者代码位置，来提高性能</td>
</tr>
<tr>
<td>FFT使用例程</td>
<td>本例程主要作用是，展示如何使用英飞凌SDK自带的软件FFT计算</td>
</tr>
</tbody>
</table>
<p>E1:配置IO口，点灯（略）</p>
<p>E2:利用串口发送/接受信息，注意中断的配置</p>
<p>E3:ADC,主要函数有adc_convert();
adc_mean_filter_convert();参数是ADC通道等</p>
<p>E4：pwm制作呼吸灯</p>
<p>E5:利用中断控制灯的亮灭</p>
<p>E6:中断嵌套的应用</p>
<p>E7:利用中断读取编码器的输出值</p>
<p>E8:利用串口输出数据至串口助手</p>
<p>E9:利用system_getval_ms();来获取系统从运行到现在的时间，也可以us</p>
<p>...双核的使用建议看E14,详细解释了分配规则：</p>
<ul>
<li><p>CPU0是一级流水线，CPU1是三级流水线，因此CPU1更适合做运算，速度会比CPU0快一些</p></li>
<li><p>CPU0 psram 程序RAM 大小为16KB CPU0 dsram 数据RAM
大小为72KB</p></li>
<li><p>CPU1 psram 程序RAM 大小为32KB CPU1 dsram 数据RAM
大小为120KB</p></li>
<li><p>TC264D中两个核心都有自己的程序缓存， CPU0 Cache大小为8KB CPU1
Cache大小为16KB</p></li>
<li><p>程序RAM用来放代码，将代码放在RAM中，可以提高执行速度，特别是当周期运行的代码大小超过了cache之后效果比较显著。数据RAM用来放变量，任意CPU都可以访问dsram0和dsram1，也就是说CPU0可以访问dsram1，这种行为叫做跨核访问，带来的问题就是访问延迟有所增大；最好的是CPU0访问dsram0，CPU1访问dsram1，这样速度最快。
默认情况下定义的全局变量都是保存在dsram1中的，这就会导致在CPU0中跑的代码对RAM读取会有一定的延迟。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> section all <span class="string">"cpu0_dsram"</span>  <span class="comment">// 将变量放在cpu0_dsram区域内</span></span></span><br><span class="line">uint8 test_value = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 如果将cpu0_dsram改为cpu1_dsram  则变量放在cpu1_dsram区域内</span></span><br><span class="line"><span class="comment">// 我们建议程序由哪个CPU执行，则将所使用的变量放置在哪个区域内，默认不指定的情况下变量被放置在cpu1_dsram区域</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> section all restore</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用#pragma section all "cpu0_psram" 和 #pragma section all restore可以将函数加载到cpu0_psram</span></span><br><span class="line"><span class="comment">// 我们只需要将函数定义放在上面两句话中间即可，使用示例如下</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> section all <span class="string">"cpu0_psram"</span>  <span class="comment">// 将函数加载到cpu0_psram区域内执行</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">delay_tset</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    uint32 i;</span><br><span class="line">    i = <span class="number">16000000</span>;</span><br><span class="line">    <span class="keyword">while</span>(i--);</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 如果将cpu0_psram改为cpu1_psram  则函数加载到cpu1_psram区域内</span></span><br><span class="line"><span class="comment">// 我们建议程序由哪个CPU执行，则将函数加载到在哪个区域内，默认不指定的情况下，程序都是从flash加载并执行</span></span><br><span class="line"><span class="comment">// 通常我们都不需要将函数放在RAM运行，一般在周期执行的程序大小超过了cache后，会出现程序执行速度降低，这个时候我们就可以将部分代码放入RAM执行，可以提高运算速度</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> section all restore</span></span><br></pre></td></tr></table></figure></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> I_ex, I_ey, I_ez;  <span class="comment">//误差积分</span></span><br><span class="line"><span class="type">float</span> param_Kp = <span class="number">50.0</span>;   <span class="comment">//加速度计的收敛速率比例增益 50</span></span><br><span class="line"><span class="type">float</span> param_Ki = <span class="number">0.20</span>;   <span class="comment">//陀螺仪收敛速率的积分增益 0.2</span></span><br><span class="line"><span class="comment">//姿态解算融合，是Crazepony和核心算法。使用的是互补滤波算法</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">IMU_AHRSupdate_noMagnetic</span><span class="params">(<span class="type">float</span> gx, <span class="type">float</span> gy, <span class="type">float</span> gz, <span class="type">float</span> ax, <span class="type">float</span> ay, <span class="type">float</span> az)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">float</span> halfT = <span class="number">0.5</span> * delta_T;<span class="comment">//采样周期一半</span></span><br><span class="line">    <span class="type">float</span> vx, vy, vz;           <span class="comment">//当前的机体坐标系上的重力单位向量</span></span><br><span class="line">    <span class="type">float</span> ex, ey, ez;           <span class="comment">//四元数计算值与加速度计测量值的误差</span></span><br><span class="line">    <span class="comment">//四元数</span></span><br><span class="line">    <span class="type">float</span> q0 = Q_info.q0;</span><br><span class="line">    <span class="type">float</span> q1 = Q_info.q1;</span><br><span class="line">    <span class="type">float</span> q2 = Q_info.q2;</span><br><span class="line">    <span class="type">float</span> q3 = Q_info.q3;</span><br><span class="line">    <span class="comment">//四元数相乘，方便后面的计算</span></span><br><span class="line">    <span class="type">float</span> q0q0 = q0 * q0;</span><br><span class="line">    <span class="type">float</span> q0q1 = q0 * q1;</span><br><span class="line">    <span class="type">float</span> q0q2 = q0 * q2;</span><br><span class="line">    <span class="type">float</span> q0q3 = q0 * q3;</span><br><span class="line">    <span class="type">float</span> q1q1 = q1 * q1;</span><br><span class="line">    <span class="type">float</span> q1q2 = q1 * q2;</span><br><span class="line">    <span class="type">float</span> q1q3 = q1 * q3;</span><br><span class="line">    <span class="type">float</span> q2q2 = q2 * q2;</span><br><span class="line">    <span class="type">float</span> q2q3 = q2 * q3;</span><br><span class="line">    <span class="type">float</span> q3q3 = q3 * q3;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对加速度数据进行归一化，得到单位加速度</span></span><br><span class="line">    <span class="type">float</span> norm = invSqrt(ax*ax + ay*ay + az*az);</span><br><span class="line">    ax = ax * norm;</span><br><span class="line">    ay = ay * norm;</span><br><span class="line">    az = az * norm;</span><br><span class="line">    <span class="comment">//载体坐标系下重力在三个轴上的分量</span></span><br><span class="line">    vx = <span class="number">2</span>*(q1q3 - q0q2);</span><br><span class="line">    vy = <span class="number">2</span>*(q0q1 + q2q3);</span><br><span class="line">    vz = q0q0 - q1q1 - q2q2 + q3q3;</span><br><span class="line">    <span class="comment">//g^b和a^b做向量叉乘，得到陀螺仪的校正补偿向量e的系数</span></span><br><span class="line">    ex = ay * vz - az * vy;</span><br><span class="line">    ey = az * vx - ax * vz;</span><br><span class="line">    ez = ax * vy - ay * vx;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    用叉乘误差来做PI修正陀螺零偏，</span></span><br><span class="line"><span class="comment">    通过调节 param_Kp，param_Ki 两个参数，</span></span><br><span class="line"><span class="comment">    可以控制加速度计修正陀螺仪积分姿态的速度。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//误差累加</span></span><br><span class="line">    I_ex += delta_T * ex;</span><br><span class="line">    I_ey += delta_T * ey;</span><br><span class="line">    I_ez += delta_T * ez;</span><br><span class="line">    <span class="comment">//使用PI控制器消除向量积误差（陀螺仪漂移误差）</span></span><br><span class="line">    gx = gx+ param_Kp*ex + param_Ki*I_ex;</span><br><span class="line">    gy = gy+ param_Kp*ey + param_Ki*I_ey;</span><br><span class="line">    gz = gz+ param_Kp*ez + param_Ki*I_ez;</span><br><span class="line">    <span class="comment">/*数据修正完成，下面是四元数微分方程*/</span></span><br><span class="line">    <span class="comment">//四元数微分方程，其中halfT为测量周期的1/2，gx gy gz为陀螺仪角速度，以下都是已知量，这里使用了一阶龙格库塔求解四元数微分方程</span></span><br><span class="line">    q0 = q0 + (-q1*gx - q2*gy - q3*gz)*halfT;</span><br><span class="line">    q1 = q1 + ( q0*gx + q2*gz - q3*gy)*halfT;</span><br><span class="line">    q2 = q2 + ( q0*gy - q1*gz + q3*gx)*halfT;</span><br><span class="line">    q3 = q3 + ( q0*gz + q1*gy - q2*gx)*halfT;</span><br><span class="line">    <span class="comment">//保存上一次四元数的值</span></span><br><span class="line">    norm = invSqrt(q0*q0 + q1*q1 + q2*q2 + q3*q3);  <span class="comment">//归一化系数</span></span><br><span class="line">    Q_info.q0 = q0 * norm;</span><br><span class="line">    Q_info.q1 = q1 * norm;</span><br><span class="line">    Q_info.q2 = q2 * norm;</span><br><span class="line">    Q_info.q3 = q3 * norm;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//上述的函数invSqrt是求导数的平方根：</span></span><br><span class="line"><span class="type">float</span> <span class="title function_">invSqrt</span><span class="params">(<span class="type">float</span> x)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">float</span> halfx = <span class="number">0.5f</span> * x;</span><br><span class="line">    <span class="type">float</span> y = x;</span><br><span class="line">    <span class="type">long</span> i = *(<span class="type">long</span>*)&amp;y;</span><br><span class="line">    i = <span class="number">0x5f3759df</span> - (i&gt;&gt;<span class="number">1</span>);</span><br><span class="line">    y = *(<span class="type">float</span>*)&amp;i;</span><br><span class="line">    y = y * (<span class="number">1.5f</span> - (halfx * y * y));</span><br><span class="line">    <span class="keyword">return</span> y;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//把四元数转换成欧拉角</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">IMU_quaterToEulerianAngles</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    IMUGetValues(values);   <span class="comment">//基础数据处理</span></span><br><span class="line">    IMU_AHRSupdate_noMagnetic(values[<span class="number">3</span>], values[<span class="number">4</span>], values[<span class="number">5</span>], values[<span class="number">0</span>], values[<span class="number">1</span>], values[<span class="number">2</span>]);    <span class="comment">//融合滤波解算四元数</span></span><br><span class="line">    <span class="comment">//四元数</span></span><br><span class="line">    <span class="type">float</span> q0 = Q_info.q0;</span><br><span class="line">    <span class="type">float</span> q1 = Q_info.q1;</span><br><span class="line">    <span class="type">float</span> q2 = Q_info.q2;</span><br><span class="line">    <span class="type">float</span> q3 = Q_info.q3;</span><br><span class="line">    <span class="comment">//换算欧拉角</span></span><br><span class="line">    eulerAngle.pitch = <span class="built_in">asin</span>(<span class="number">-2</span>*q1*q3 + <span class="number">2</span>*q0*q2) * <span class="number">180</span>/M_PI;                        <span class="comment">// pitch</span></span><br><span class="line">    eulerAngle.roll = <span class="built_in">atan2</span>(<span class="number">2</span>*q2*q3 + <span class="number">2</span>*q0*q1, <span class="number">-2</span>*q1*q1 - <span class="number">2</span>*q2*q2 + <span class="number">1</span>) * <span class="number">180</span>/M_PI; <span class="comment">// roll</span></span><br><span class="line">    eulerAngle.yaw = <span class="built_in">atan2</span>(<span class="number">2</span>*q1*q2 + <span class="number">2</span>*q0*q3, <span class="number">-2</span>*q2*q2 - <span class="number">2</span>*q3*q3 + <span class="number">1</span>) * <span class="number">180</span>/M_PI;  <span class="comment">// yaw</span></span><br><span class="line">}</span><br><span class="line"><span class="comment">//当然也可以作姿态限度限制，但没什么必要：</span></span><br><span class="line"><span class="comment">//    if(eulerAngle.roll&gt;90 || eulerAngle.roll&lt;-90)</span></span><br><span class="line"><span class="comment">//    {</span></span><br><span class="line"><span class="comment">//        if(eulerAngle.pitch &gt; 0)</span></span><br><span class="line"><span class="comment">//        {</span></span><br><span class="line"><span class="comment">//            eulerAngle.pitch = 180-eulerAngle.pitch;</span></span><br><span class="line"><span class="comment">//        }</span></span><br><span class="line"><span class="comment">//        if(eulerAngle.pitch &lt; 0)</span></span><br><span class="line"><span class="comment">//        {</span></span><br><span class="line"><span class="comment">//            eulerAngle.pitch = -(180+eulerAngle.pitch);</span></span><br><span class="line"><span class="comment">//        }</span></span><br><span class="line"><span class="comment">//    }</span></span><br><span class="line"><span class="comment">//    if(eulerAngle.yaw &gt; 180)</span></span><br><span class="line"><span class="comment">//    {</span></span><br><span class="line"><span class="comment">//        eulerAngle.yaw -=360;</span></span><br><span class="line"><span class="comment">//    }</span></span><br><span class="line"><span class="comment">//    else if(eulerAngle.yaw &lt;-180)</span></span><br><span class="line"><span class="comment">//    {</span></span><br><span class="line"><span class="comment">//        eulerAngle.yaw +=360;</span></span><br><span class="line"><span class="comment">//    }</span></span><br><span class="line"><span class="comment">//由此，我们得到了姿态角。</span></span><br></pre></td></tr></table></figure>
<p>附加滤波算法：</p>
<p>注意，对于各个部件选用同一种滤波方式时要区分，也即写多个同样的函数（但不同名）</p>
<p>一阶滞后滤波算法</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> FIRST_LAG_P 0.8     <span class="comment">//一阶滞后滤波系数，越小滞后效果越强</span></span></span><br><span class="line"><span class="type">float</span> <span class="title function_">FirstOrderLagFilter</span><span class="params">(<span class="type">float</span> value)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">static</span> <span class="type">float</span> last_value;  <span class="comment">//上一次滤波结果</span></span><br><span class="line"></span><br><span class="line">    value=FIRST_LAG_P*value+(<span class="number">1</span>-FIRST_LAG_P)*last_value; <span class="comment">//一阶滞后滤波</span></span><br><span class="line">    last_value=value;   <span class="comment">//保存此次滤波结果为上一次滤波结果</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>二阶滞后滤波算法与卡尔曼滤波</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_42466012/article/details/125347503">第八篇，滤波：二阶低通滤波、卡尔曼滤波-CSDN博客</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int16 <span class="title function_">SecondOrderLagFilter</span><span class="params">(int16 value)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">static</span> int16 last_value,last_2_value;</span><br><span class="line"></span><br><span class="line">    value=<span class="number">0.2</span>*value+<span class="number">0.4</span>*last_value+<span class="number">0.4</span>*last_2_value;     <span class="comment">//二阶滞后滤波</span></span><br><span class="line"></span><br><span class="line">    last_2_value=last_value;</span><br><span class="line">    last_value=value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line">    int16 x;        <span class="comment">// state</span></span><br><span class="line">    <span class="type">float</span> A;        <span class="comment">// x(n)=A*x(n-1)+u(n),u(n)~N(0,q)</span></span><br><span class="line">    <span class="type">float</span> H;        <span class="comment">// z(n)=H*x(n)+w(n),w(n)~N(0,r)</span></span><br><span class="line">    <span class="type">float</span> q;        <span class="comment">// process(predict) noise convariance</span></span><br><span class="line">    <span class="type">float</span> r;        <span class="comment">// measure noise(error) convariance</span></span><br><span class="line">    <span class="type">float</span> p;        <span class="comment">// estimated error convariance</span></span><br><span class="line">    <span class="type">float</span> gain;     <span class="comment">// kalman gain</span></span><br><span class="line">} <span class="type">kalman1_filter_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">kalman1_filter_t</span> kalman_gyro;       <span class="comment">//定义卡尔曼结构体</span></span><br><span class="line"><span class="comment">//写一个初始化函数，便于初始参数设定</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">kalman1_init</span><span class="params">(<span class="type">kalman1_filter_t</span>* state, <span class="type">float</span> q, <span class="type">float</span> r)</span></span><br><span class="line">{</span><br><span class="line">    state-&gt;x = <span class="number">0</span>;</span><br><span class="line">    state-&gt;p = <span class="number">0.0f</span>;</span><br><span class="line">    state-&gt;A = <span class="number">1.0f</span>;</span><br><span class="line">    state-&gt;H = <span class="number">1.0f</span>;</span><br><span class="line">    state-&gt;q = q;</span><br><span class="line">    state-&gt;r = r;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//滤波算法</span></span><br><span class="line">int16 <span class="title function_">kalman1_filter</span><span class="params">(<span class="type">kalman1_filter_t</span>* state, <span class="type">float</span> z_measure)</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">/* Predict */</span></span><br><span class="line">    <span class="comment">// 时间更新(预测): X(k|k-1) = A(k,k-1)*X(k-1|k-1) + B(k)*u(k)</span></span><br><span class="line">    state-&gt;x = state-&gt;A * state-&gt;x;</span><br><span class="line">    <span class="comment">// 更新先验协方差: P(k|k-1) = A(k,k-1)*A(k,k-1)^T*P(k-1|k-1)+Q(k)</span></span><br><span class="line">    state-&gt;p = state-&gt;A * state-&gt;A * state-&gt;p + state-&gt;q;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Measurement */</span></span><br><span class="line">    <span class="comment">// 计算卡尔曼增益: K(k) = P(k|k-1)*H(k)^T/(P(k|k-1)*H(k)*H(k)^T + R(k))</span></span><br><span class="line">    state-&gt;gain = state-&gt;p * state-&gt;H / (state-&gt;p * state-&gt;H * state-&gt;H + state-&gt;r);</span><br><span class="line">    <span class="comment">// 测量更新(校正): X(k|k) = X(k|k-1)+K(k)*(Z(k)-H(k)*X(k|k-1))</span></span><br><span class="line">    state-&gt;x = state-&gt;x + state-&gt;gain * (z_measure - state-&gt;H * state-&gt;x);</span><br><span class="line">    <span class="comment">// 更新后验协方差: P(k|k) =（I-K(k)*H(k))*P(k|k-1)</span></span><br><span class="line">    state-&gt;p = (<span class="number">1</span> - state-&gt;gain * state-&gt;H) * state-&gt;p;</span><br><span class="line">    <span class="keyword">return</span> state-&gt;x;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>模糊PID算法:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//对数据模糊化的宏定义{NB,NM,NS,ZO,PS,PM,PB},不用数组是因为方便后面规则表的编写</span></span><br><span class="line"><span class="comment">//******************模糊子集******************************</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NB -3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NM -2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NS -1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ZO  0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PS  1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PM  2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PB  3</span></span><br><span class="line"><span class="comment">//*******************************************************</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//隶属值的单位值：FuzzyArray[]*这个=隶属值，该值需要调参使用，(MAX-MIN)/8得到</span></span><br><span class="line"><span class="comment">/*******************物理论域宏定义****************************/</span></span><br><span class="line"><span class="comment">//*******************************************************</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BiasMembership 60 <span class="comment">//偏差</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BiasCMembership 10<span class="comment">//偏差于上一次偏差的差</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SteerKP 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SteerKd 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MotorKP 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MotorKI 1</span></span><br><span class="line"><span class="comment">//********************************************************</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*************************模糊规则***********************/</span></span><br><span class="line">uint8 KPFuzzyRule[<span class="number">7</span>][<span class="number">7</span>]={{PB,PB,PM,PM,PS,ZO,ZO},</span><br><span class="line">                         {PB,PB,PM,PS,PS,ZO,NS},</span><br><span class="line">                         {PM,PM,PM,PS,ZO,NS,NS},</span><br><span class="line">                         {PM,PM,PS,ZO,NS,NM,NM},</span><br><span class="line">                         {PS,PS,ZO,NS,NS,NM,NM},</span><br><span class="line">                         {PS,ZO,NS,NM,NM,NM,NB},</span><br><span class="line">                         {ZO,ZO,NM,NM,NM,NB,NB}};<span class="comment">//KP参数的模糊规则表</span></span><br><span class="line">uint8 KIFuzzyRule[<span class="number">7</span>][<span class="number">7</span>]={{NB,NB,NM,NM,NS,ZO,ZO},</span><br><span class="line">                         {NB,NB,NM,NS,NS,ZO,ZO},</span><br><span class="line">                         {NB,NM,NS,NS,ZO,PS,PS},</span><br><span class="line">                         {NM,NM,NS,ZO,PS,PM,PM},</span><br><span class="line">                         {NM,NS,ZO,PS,PS,PM,PB},</span><br><span class="line">                         {ZO,ZO,PS,PS,PM,PB,PB},</span><br><span class="line">                         {ZO,ZO,PS,PM,PM,PB,PB}};<span class="comment">//KI参数的模糊规则表</span></span><br><span class="line">uint8 KDFuzzyRule[<span class="number">7</span>][<span class="number">7</span>]={{PS,NS,NB,NB,NB,NM,PS},</span><br><span class="line">                         {PS,NS,NB,NM,NM,NS,ZO},</span><br><span class="line">                         {ZO,NS,NM,NM,NS,NS,ZO},</span><br><span class="line">                         {ZO,NS,NS,NS,NS,NS,ZO},</span><br><span class="line">                         {ZO,ZO,ZO,ZO,ZO,ZO,ZO},</span><br><span class="line">                         {PB,NS,PS,PS,PS,PS,PB},</span><br><span class="line">                         {PB,PM,PM,PM,PS,PS,PB}};<span class="comment">//KD参数的模糊规则表</span></span><br><span class="line"><span class="comment">/**********************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//求出偏差的隶属值与隶属度</span></span><br><span class="line"><span class="comment">//float E: 偏差/偏差论域宏定义（把他们限制在-3~3之间）</span></span><br><span class="line"><span class="comment">//float Membership[2]: 用于存储传进来参数两个隶属度的数组，M[0]是比较小的模糊子集的隶属度</span></span><br><span class="line"><span class="comment">//int Index[2]: 索引数组，用于索引规则表，跟Membership同理M[0]是比较小的模糊子集的索引值</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ClacMembership</span><span class="params">(<span class="type">float</span> E,<span class="type">float</span> Membership[<span class="number">2</span>],<span class="type">int</span> Index[<span class="number">2</span>])</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">/*三角隶属度函数*/</span></span><br><span class="line">    <span class="keyword">if</span>(E&gt;=NB &amp;&amp; E&lt;=NM)</span><br><span class="line">    {</span><br><span class="line">        Index[<span class="number">0</span>]=<span class="number">0</span>;<span class="comment">//NB</span></span><br><span class="line">        Index[<span class="number">1</span>]=<span class="number">1</span>;<span class="comment">//NM</span></span><br><span class="line">        Membership[<span class="number">0</span>]=NM-E;<span class="comment">//隶属于NB的隶属度(NM-E)/(NM-NB)，因为分母都是1</span></span><br><span class="line">        Membership[<span class="number">1</span>]=E-NB;<span class="comment">//隶属于NM的隶属度(E-NB)/(NM-NB)</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(E&gt;=NM &amp;&amp; E&lt;=NS)</span><br><span class="line">    {</span><br><span class="line">        Index[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        Index[<span class="number">1</span>]=<span class="number">2</span>;</span><br><span class="line">        Membership[<span class="number">0</span>]=NS-E;<span class="comment">//隶属于NM的隶属度</span></span><br><span class="line">        Membership[<span class="number">1</span>]=E-NM;<span class="comment">//隶属于NS的隶属度</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(E&gt;=NS &amp;&amp; E&lt;=ZO)</span><br><span class="line">    {</span><br><span class="line">        Index[<span class="number">0</span>]=<span class="number">2</span>;</span><br><span class="line">        Index[<span class="number">1</span>]=<span class="number">3</span>;</span><br><span class="line">        Membership[<span class="number">0</span>]=ZO-E;<span class="comment">//隶属于NS的隶属度</span></span><br><span class="line">        Membership[<span class="number">1</span>]=E-NS;<span class="comment">//隶属于ZO的隶属度</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(E&gt;=ZO &amp;&amp; E&lt;=PS)</span><br><span class="line">    {</span><br><span class="line">        Index[<span class="number">0</span>]=<span class="number">3</span>;</span><br><span class="line">        Index[<span class="number">1</span>]=<span class="number">4</span>;</span><br><span class="line">        Membership[<span class="number">0</span>]=PS-E;<span class="comment">//隶属于ZO的隶属度</span></span><br><span class="line">        Membership[<span class="number">1</span>]=E-ZO;<span class="comment">//隶属于PS的隶属度</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(E&gt;=PS &amp;&amp; E&lt;=PM)</span><br><span class="line">    {</span><br><span class="line">        Index[<span class="number">0</span>]=<span class="number">4</span>;</span><br><span class="line">        Index[<span class="number">1</span>]=<span class="number">5</span>;</span><br><span class="line">        Membership[<span class="number">0</span>]=PM-E;<span class="comment">//隶属于PS的隶属度</span></span><br><span class="line">        Membership[<span class="number">1</span>]=E-PS;<span class="comment">//隶属于PM的隶属度</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(E&gt;=PM &amp;&amp; E&lt;=PB)</span><br><span class="line">    {</span><br><span class="line">        Index[<span class="number">0</span>]=<span class="number">5</span>;</span><br><span class="line">        Index[<span class="number">1</span>]=<span class="number">6</span>;</span><br><span class="line">        Membership[<span class="number">0</span>]=PB-E;<span class="comment">//隶属于PS的隶属度</span></span><br><span class="line">        Membership[<span class="number">1</span>]=E-PM;<span class="comment">//隶属于PM的隶属度</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据模糊规则表以及重心法求出输出</span></span><br><span class="line"><span class="comment">// 参    数: int IndexE[2]: 偏差的索引数组</span></span><br><span class="line"><span class="comment">//float MSE[2]: 偏差对于两个隶属值的隶属度数组</span></span><br><span class="line"><span class="comment">//int IndexEC[2]: 偏差变化率的索引数组</span></span><br><span class="line"><span class="comment">//float MSEC[2]: 偏差变化率对于两个隶属值的隶属度数组</span></span><br><span class="line"><span class="comment">//int type: 1：KP 2：KI 3：KD</span></span><br><span class="line"><span class="comment">//返 回 值: K的增量K=K0+detaK*比例系数</span></span><br><span class="line"><span class="type">int</span>  <span class="title function_">SolutionFuzzy</span><span class="params">(<span class="type">int</span> IndexE[<span class="number">2</span>],<span class="type">float</span> MSE[<span class="number">2</span>],<span class="type">int</span> IndexEC[<span class="number">2</span>],<span class="type">float</span> MSEC[<span class="number">2</span>],<span class="type">int</span> type)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> temp=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">switch</span>(type)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="comment">//重心法求解</span></span><br><span class="line">            temp=KPFuzzyRule[IndexE[<span class="number">0</span>]][IndexEC[<span class="number">0</span>]]*MSE[<span class="number">0</span>]*MSEC[<span class="number">0</span>]+</span><br><span class="line">                 KPFuzzyRule[IndexE[<span class="number">0</span>]][IndexEC[<span class="number">1</span>]]*MSE[<span class="number">0</span>]*MSEC[<span class="number">1</span>]+</span><br><span class="line">                 KPFuzzyRule[IndexE[<span class="number">1</span>]][IndexEC[<span class="number">0</span>]]*MSE[<span class="number">1</span>]*MSEC[<span class="number">0</span>]+</span><br><span class="line">                 KPFuzzyRule[IndexE[<span class="number">1</span>]][IndexEC[<span class="number">1</span>]]*MSE[<span class="number">1</span>]*MSEC[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            temp=KIFuzzyRule[IndexE[<span class="number">0</span>]][IndexEC[<span class="number">0</span>]]*MSE[<span class="number">0</span>]*MSEC[<span class="number">0</span>]+</span><br><span class="line">                 KIFuzzyRule[IndexE[<span class="number">0</span>]][IndexEC[<span class="number">1</span>]]*MSE[<span class="number">0</span>]*MSEC[<span class="number">1</span>]+</span><br><span class="line">                 KIFuzzyRule[IndexE[<span class="number">1</span>]][IndexEC[<span class="number">0</span>]]*MSE[<span class="number">1</span>]*MSEC[<span class="number">0</span>]+</span><br><span class="line">                 KIFuzzyRule[IndexE[<span class="number">1</span>]][IndexEC[<span class="number">1</span>]]*MSE[<span class="number">1</span>]*MSEC[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            temp=KDFuzzyRule[IndexE[<span class="number">0</span>]][IndexEC[<span class="number">0</span>]]*MSE[<span class="number">0</span>]*MSEC[<span class="number">0</span>]+</span><br><span class="line">                 KDFuzzyRule[IndexE[<span class="number">0</span>]][IndexEC[<span class="number">1</span>]]*MSE[<span class="number">0</span>]*MSEC[<span class="number">1</span>]+</span><br><span class="line">                 KDFuzzyRule[IndexE[<span class="number">1</span>]][IndexEC[<span class="number">0</span>]]*MSE[<span class="number">1</span>]*MSEC[<span class="number">0</span>]+</span><br><span class="line">                 KDFuzzyRule[IndexE[<span class="number">1</span>]][IndexEC[<span class="number">1</span>]]*MSE[<span class="number">1</span>]*MSEC[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2><span id="图像处理部分">图像处理部分：</span></h2>
<h4><span id="图像阈值二值化">图像阈值二值化</span></h4>
<p>首先进行图像的二值化：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_BLACK 0<span class="comment">//二值化的黑点</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_WHITE 255<span class="comment">//二值化的白点，用在二值化图像以及扫线那里</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_COMPRESS_W    80<span class="comment">//压缩之后的图像宽度</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_COMPRESS_H    60<span class="comment">//压缩之后的图像高度</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGECOMPRESS 0<span class="comment">//是否开启图像压缩的二值化，1：是 0：否 压缩图像帧率记得调成230</span></span></span><br><span class="line">uint8 CompressImage[IMAGE_COMPRESS_H][IMAGE_COMPRESS_W] = {<span class="number">0</span>}; <span class="comment">//存储压缩之后的灰度图</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> IMAGECOMPRESS</span></span><br><span class="line">uint8 BinaryImage[IMAGE_COMPRESS_H][IMAGE_COMPRESS_W] = {<span class="number">0</span>}; <span class="comment">//压缩图像之后的二值化图像</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">uint8 BinaryImage[MT9V03X_H][MT9V03X_W] = {<span class="number">0</span>};                                     <span class="comment">//二值化图像</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//上述宏定义中，用到了：</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MT9V03X_W               160  <span class="comment">//图像宽度 范围1-188 //对封装库的修改：适配LCD屏幕的大小</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MT9V03X_H               120             	<span class="comment">//图像高度	范围1-120</span></span></span><br></pre></td></tr></table></figure>
<p>对应的处理函数有（自适应建议用，opencv经典算法）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">uint8 <span class="title function_">otsuThreshold</span><span class="params">(uint8 *image, uint16 width, uint16 height)</span>;     <span class="comment">//计算二值化阈值: 大津法 3ms</span></span><br><span class="line">uint8 <span class="title function_">GuDiThreshold</span><span class="params">(uint16 width, uint16 height)</span>;     <span class="comment">//计算二值化阈值：谷底最小值 2ms</span></span><br><span class="line">uint8 <span class="title function_">OneDimensionalThreshold</span><span class="params">(uint16 width, uint16 height)</span>; <span class="comment">//计算二值化阈值 4ms</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">adaptiveThreshold</span><span class="params">(uint8 *img_data, uint8 *output_data, <span class="type">int</span> width, <span class="type">int</span> height, <span class="type">int</span> block, uint8 clip_value)</span>;<span class="comment">//自适应阈值二值化</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Get_Compress_Image</span><span class="params">(<span class="type">void</span>)</span>; <span class="comment">//压缩原始灰度图像再进行二值化，速度是之前的一半之前二值化一张图5ms，现在1.5ms</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ImageBinary</span><span class="params">(<span class="type">void</span>)</span>; <span class="comment">//根据阈值二值化图像</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  @brief  大津法二值化0.8ms程序（实际测试4ms在TC264中）</span></span><br><span class="line"><span class="comment"> *  *image ：图像地址</span></span><br><span class="line"><span class="comment"> *  width:  图像宽</span></span><br><span class="line"><span class="comment"> *  height：图像高</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">uint8 <span class="title function_">otsuThreshold</span><span class="params">(uint8 *image, uint16 width, uint16 height)</span></span><br><span class="line">{</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GrayScale 256</span></span><br><span class="line">    <span class="type">int</span> pixelCount[GrayScale] = {<span class="number">0</span>}; <span class="comment">//每个灰度值所占像素个数</span></span><br><span class="line">    <span class="type">float</span> pixelPro[GrayScale] = {<span class="number">0</span>}; <span class="comment">//每个灰度值所占总像素比例</span></span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    <span class="type">int</span> Sumpix = width * height; <span class="comment">//总像素点</span></span><br><span class="line">    uint8 threshold = <span class="number">0</span>;</span><br><span class="line">    uint8 *data = image; <span class="comment">//指向像素数据的指针</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//统计灰度级中每个像素在整幅图像中的个数</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; height; i++)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; width; j++)</span><br><span class="line">        {</span><br><span class="line">            pixelCount[(<span class="type">int</span>)data[i * width + j]]++; <span class="comment">//将像素值作为计数数组的下标</span></span><br><span class="line">                                                    <span class="comment">//   pixelCount[(int)image[i][j]]++;    若不用指针用这个</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="type">float</span> u = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; GrayScale; i++)</span><br><span class="line">    {</span><br><span class="line">        pixelPro[i] = (<span class="type">float</span>)pixelCount[i] / Sumpix; <span class="comment">//计算每个像素在整幅图像中的比例</span></span><br><span class="line">        u += i * pixelPro[i];                        <span class="comment">//总平均灰度</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> maxVariance = <span class="number">0.0</span>;      <span class="comment">//最大类间方差</span></span><br><span class="line">    <span class="type">float</span> w0 = <span class="number">0</span>, avgValue = <span class="number">0</span>;   <span class="comment">//w0 前景比例 ，avgValue 前景平均灰度</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++) <span class="comment">//每一次循环都是一次完整类间方差计算 (两个for叠加为1个)</span></span><br><span class="line">    {</span><br><span class="line">        w0 += pixelPro[i]; <span class="comment">//假设当前灰度i为阈值, 0~i 灰度像素所占整幅图像的比例即前景比例</span></span><br><span class="line">        avgValue += i * pixelPro[i];</span><br><span class="line"></span><br><span class="line">        <span class="type">float</span> variance = <span class="built_in">pow</span>((avgValue / w0 - u), <span class="number">2</span>) * w0 / (<span class="number">1</span> - w0); <span class="comment">//类间方差</span></span><br><span class="line">        <span class="keyword">if</span> (variance &gt; maxVariance)</span><br><span class="line">        {</span><br><span class="line">            maxVariance = variance;</span><br><span class="line">            threshold = (uint8)i;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> threshold;</span><br><span class="line">}</span><br><span class="line"><span class="comment">/***************************************************************************</span></span><br><span class="line"><span class="comment"> ** 函数功能: 谷底最小值二值化算法</span></span><br><span class="line"><span class="comment"> ** 参    数: uint16 width : 图像宽度</span></span><br><span class="line"><span class="comment"> **           uint16 height: 图像高度</span></span><br><span class="line"><span class="comment"> ** 返 回 值: 二值化阈值</span></span><br><span class="line"><span class="comment"> ** 注    意：运用了摄像头采集的灰度图像的全局变量</span></span><br><span class="line"><span class="comment"> *************************************************************************/</span></span><br><span class="line">uint8 <span class="title function_">GuDiThreshold</span><span class="params">(uint16 width, uint16 height)</span> <span class="comment">//计算二值化阈值：谷底最小值</span></span><br><span class="line">{</span><br><span class="line">    uint16 graynum[<span class="number">256</span>] = {<span class="number">0</span>};</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; height; ++i)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; width; ++j)</span><br><span class="line">        {</span><br><span class="line">            uint8 pix = mt9v03x_image[i][j];</span><br><span class="line">            graynum[pix]++;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    uint8 Max[<span class="number">2</span>] = {<span class="number">0</span>};</span><br><span class="line">    uint8 index[<span class="number">2</span>] = {<span class="number">0</span>};</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">for</span> (uint16 j = <span class="number">0</span>; j &lt; <span class="number">256</span>; ++j)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span>)</span><br><span class="line">            {</span><br><span class="line">                <span class="keyword">if</span> (graynum[j] &gt; Max[i])</span><br><span class="line">                {</span><br><span class="line">                    Max[i] = graynum[j];</span><br><span class="line">                    index[i] = j;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            {</span><br><span class="line">                <span class="keyword">if</span> (graynum[j] &gt; Max[i] &amp;&amp; graynum[j] != Max[<span class="number">0</span>])</span><br><span class="line">                {</span><br><span class="line">                    Max[i] = graynum[j];</span><br><span class="line">                    index[i] = j;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (index[<span class="number">0</span>] &gt; index[<span class="number">1</span>])</span><br><span class="line">    {</span><br><span class="line">        uint8 temp = <span class="number">0</span>;</span><br><span class="line">        temp = index[<span class="number">0</span>];</span><br><span class="line">        index[<span class="number">0</span>] = index[<span class="number">1</span>];</span><br><span class="line">        index[<span class="number">1</span>] = temp;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    uint8 Min = <span class="number">255</span>, index_Min = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (uint8 i = index[<span class="number">0</span>]; i &lt; index[<span class="number">1</span>]; ++i)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (graynum[i] &lt; Min)</span><br><span class="line">        {</span><br><span class="line">            Min = graynum[i];</span><br><span class="line">            index_Min = i;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> index_Min;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *******************************************************************************************</span></span><br><span class="line"><span class="comment"> ** 函数功能: 类似一维Means的二值化阈值计算</span></span><br><span class="line"><span class="comment"> ** 参    数: width：图像宽度</span></span><br><span class="line"><span class="comment"> **           height：图像高度</span></span><br><span class="line"><span class="comment"> ** 返 回 值: 二值化阈值********************************************************************************************</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">uint8 <span class="title function_">OneDimensionalThreshold</span><span class="params">(uint16 width, uint16 height)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> row, cloum;</span><br><span class="line">    <span class="type">int</span> G1, G2;</span><br><span class="line">    <span class="type">int</span> g1, g2;</span><br><span class="line">    uint8 threshold = <span class="number">160</span>, threshold_last = <span class="number">0</span>; <span class="comment">//阈值与上一次阈值，初始化为不同的值，第一个阈值是认为随机设定的</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">abs</span>(threshold - threshold_last) &gt; <span class="number">10</span>) <span class="comment">//只有当连续两次计算的阈值相等时才会跳出while</span></span><br><span class="line">    {</span><br><span class="line">        <span class="comment">//初始化数据</span></span><br><span class="line">        G1 = <span class="number">0</span>;</span><br><span class="line">        G2 = <span class="number">0</span>;</span><br><span class="line">        g1 = <span class="number">0</span>;</span><br><span class="line">        g2 = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//进行G1和G2的分类</span></span><br><span class="line">        <span class="keyword">for</span> (row = <span class="number">0</span>; row &lt; height; row++)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">for</span> (cloum = <span class="number">0</span>; cloum &lt; width; cloum++)</span><br><span class="line">            {</span><br><span class="line">                <span class="keyword">if</span> (mt9v03x_image[row][cloum] &gt; threshold)</span><br><span class="line">                {</span><br><span class="line">                    G1 += mt9v03x_image[row][cloum];</span><br><span class="line">                    g1++;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                {</span><br><span class="line">                    G2 += mt9v03x_image[row][cloum];</span><br><span class="line">                    g2++;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//进行新阈值的计算</span></span><br><span class="line">        threshold_last = threshold;              <span class="comment">//保存上一次的阈值</span></span><br><span class="line">        threshold = ((G1 / g1) + (G2 / g2)) / <span class="number">2</span>; <span class="comment">//阈值=（G1平均值+G2平均值）/ 2</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> threshold;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据场地条件调用大津法或谷底最小值得到二值化阈值然后根据灰度图得到黑白图像</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ImageBinary</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> IMAGECOMPRESS</span></span><br><span class="line">    <span class="comment">//压缩图像的二值化</span></span><br><span class="line">    uint8 Image_Threshold = otsuThreshold(CompressImage[<span class="number">0</span>], IMAGE_COMPRESS_W, IMAGE_COMPRESS_H); <span class="comment">//使用大津法得到二值化阈值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; IMAGE_COMPRESS_H; ++i)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; IMAGE_COMPRESS_W; ++j)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">if</span> (CompressImage[i][j] &lt;= Image_Threshold) <span class="comment">//进行二值化之前只是得到阈值</span></span><br><span class="line">                BinaryImage[i][j] = IMAGE_BLACK;        <span class="comment">//0是黑色  //图像原点不变</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                BinaryImage[i][j] = IMAGE_WHITE; <span class="comment">//1是白色  //图像原点不变</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    uint8 Image_Threshold = otsuThreshold(mt9v03x_image[<span class="number">0</span>], MT9V03X_W, MT9V03X_H);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MT9V03X_H; ++i)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; MT9V03X_W; ++j)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">if</span> (mt9v03x_image[i][j] &lt;= Image_Threshold) <span class="comment">//进行二值化之前只是得到阈值</span></span><br><span class="line">                BinaryImage[i][j] = IMAGE_BLACK;        <span class="comment">//0是黑色  //图像原点不变</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                BinaryImage[i][j] = IMAGE_WHITE; <span class="comment">//1是白色  //图像原点不变</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/********************************************************************************************</span></span><br><span class="line"><span class="comment"> ** 函数功能: 自适应阈值二值化图像</span></span><br><span class="line"><span class="comment"> ** 参    数: uint8* img_data：灰度图像</span></span><br><span class="line"><span class="comment"> **           uint8* output_data：二值化图像</span></span><br><span class="line"><span class="comment"> **           int width：图像宽度</span></span><br><span class="line"><span class="comment"> **           int height：图像高度</span></span><br><span class="line"><span class="comment"> **           int block：分割局部阈值的方块大小例如7*7</span></span><br><span class="line"><span class="comment"> **           uint8 clip_value: 局部阈值减去的经验值一般为（2~5）</span></span><br><span class="line"><span class="comment"> ** 返 回 值: 无</span></span><br><span class="line"><span class="comment"> ** 作    者: 上海交大16届智能车智能视觉组SJTUAuTop</span></span><br><span class="line"><span class="comment"> **           https://zhuanlan.zhihu.com/p/391051197</span></span><br><span class="line"><span class="comment"> ** 注    意：adaptiveThreshold(mt9v03x_image[0],BinaryImage[0],MT9V03X_W,MT9V03X_H,5,1);//但是没d用跟大津法一样</span></span><br><span class="line"><span class="comment"> *********************************************************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">adaptiveThreshold</span><span class="params">(uint8 *img_data, uint8 *output_data, <span class="type">int</span> width, <span class="type">int</span> height, <span class="type">int</span> block, uint8 clip_value)</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">//  assert(block % 2 == 1); // block必须为奇数</span></span><br><span class="line">    <span class="type">int</span> half_block = block / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> y = half_block; y &lt; height - half_block; y++)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> x = half_block; x &lt; width - half_block; x++)</span><br><span class="line">        {</span><br><span class="line">            <span class="comment">// 计算局部阈值</span></span><br><span class="line">            <span class="type">int</span> thres = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> dy = -half_block; dy &lt;= half_block; dy++)</span><br><span class="line">            {</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> dx = -half_block; dx &lt;= half_block; dx++)</span><br><span class="line">                {</span><br><span class="line">                    thres += img_data[(x + dx) + (y + dy) * width];</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            thres = thres / (block * block) - clip_value;</span><br><span class="line">            <span class="comment">// 进行二值化</span></span><br><span class="line">            output_data[x + y * width] = img_data[x + y * width] &gt; thres ? <span class="number">255</span> : <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment"> *  函数名称：void Get_Use_Image (void)</span></span><br><span class="line"><span class="comment"> *  功能说明：把摄像头采集到原始图像，缩放到赛道识别所需大小</span></span><br><span class="line"><span class="comment"> *  参数说明：无</span></span><br><span class="line"><span class="comment"> *  函数返回：无</span></span><br><span class="line"><span class="comment"> *  备    注： IMAGE_COMPRESS_H:为图像压缩之后的高度120/2=60</span></span><br><span class="line"><span class="comment"> *             IMAGE_COMPRESS_W:为图像压缩之后的高度160/2=80</span></span><br><span class="line"><span class="comment"> *             帧率230的条件下压缩完之后二值化搜线找拐点采集图像的时间为2.3~2.5ms，未压缩：8.0ms，帧率400的时候为5ms</span></span><br><span class="line"><span class="comment"> *             顺便在压缩的时候进行了个均值滤波，对灰度图滤波这个像素点和旁边那个滤去的求均值</span></span><br><span class="line"><span class="comment"> *             看起来跟原来没太大差别，因为环境不恶劣，可以删去，耗时加了0.2ms</span></span><br><span class="line"><span class="comment"> *************************************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Get_Compress_Image</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">short</span> i = <span class="number">0</span>, j = <span class="number">0</span>, row = <span class="number">0</span>, line = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MT9V03X_H; i += <span class="number">2</span>) <span class="comment">//神眼高 120 / 2  = 60，</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt;= MT9V03X_W; j += <span class="number">2</span>) <span class="comment">//神眼宽188 / 2  = 94，</span></span><br><span class="line">        {</span><br><span class="line">            CompressImage[row][line] = mt9v03x_image[i][j];</span><br><span class="line">            <span class="comment">//            CompressImage[row][line] = (mt9v03x_image[i][j]+mt9v03x_image[i][j-1])/2;</span></span><br><span class="line">            line++;</span><br><span class="line">        }</span><br><span class="line">        line = <span class="number">0</span>;</span><br><span class="line">        row++;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h4><span id="识别边界拐点等">识别边界拐点等：</span></h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> BORDER_BIAS 1   <span class="comment">//扫线误差</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INFLECTION_WIDTH  10    <span class="comment">//拐点赛道宽度</span></span></span><br><span class="line">uint8 Mid=MT9V03X_W/<span class="number">2</span>;                        <span class="comment">//初始化扫线的中点为图像中点</span></span><br><span class="line">uint8 Lost_Row=<span class="number">0</span>;                             <span class="comment">//中线丢失的行坐标(扫线到赛道外)</span></span><br><span class="line">uint8 LostNum_LeftLine=<span class="number">0</span>,LostNum_RightLine=<span class="number">0</span>; <span class="comment">//记录左右边界丢线数</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="type">int</span> X;</span><br><span class="line">    <span class="type">int</span> Y;</span><br><span class="line">}Point; <span class="comment">//点坐标的结构体</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">GetImagBasic</span><span class="params">(<span class="type">int</span> *LeftLine, <span class="type">int</span> *CentreLine, <span class="type">int</span> *RightLine ,<span class="type">char</span> path)</span>;  <span class="comment">//扫线提取左中右三线</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">GetDownInflection</span><span class="params">(<span class="type">int</span> startline,<span class="type">int</span> endline,<span class="type">int</span> *LeftLine,<span class="type">int</span> *RightLine,Point *InflectionL,Point *InflectionR)</span>;<span class="comment">//根据左右边界线来得到下拐点（十字、三岔、环岛）</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">GetUpInflection</span><span class="params">(<span class="type">char</span> Choose,<span class="type">int</span> startline,<span class="type">int</span> endline,Point *UpInflection)</span>;<span class="comment">//根据遍历左右线得到行与行之间的列坐标的差值，大于设定的阈值则判断为是上拐点</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">GetRightangleUPInflection</span><span class="params">(<span class="type">char</span> Choose,Point DowmInflection,Point *UpInflection,<span class="type">int</span> ROWTHR,<span class="type">int</span> CLOUMNTHR)</span>;<span class="comment">//根据二值化图像找直角上拐点</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Bin_Image_Filter</span><span class="params">(<span class="type">void</span>)</span>;<span class="comment">//图像腐蚀</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MeasureWidth</span><span class="params">(<span class="type">int</span> startline,<span class="type">int</span> endline)</span>;<span class="comment">//测量赛道宽度</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">GetImagBasic_Garage</span><span class="params">(<span class="type">int</span> *LeftLine, <span class="type">int</span> *CentreLine, <span class="type">int</span> *RightLine ,<span class="type">char</span> path)</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> ** 函数功能: 扫线提取左中右三线的坐标</span></span><br><span class="line"><span class="comment"> ** 参    数: *LeftLine：左线数组</span></span><br><span class="line"><span class="comment"> **           *CentreLine：中线数组</span></span><br><span class="line"><span class="comment"> **           *RightLine：右线数组</span></span><br><span class="line"><span class="comment"> **           path：默认扫线方向</span></span><br><span class="line"><span class="comment"> ** 返 回 值: 无</span></span><br><span class="line"><span class="comment"> ** 作    者: WBN</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">GetImagBasic</span><span class="params">(<span class="type">int</span> *LeftLine, <span class="type">int</span> *CentreLine, <span class="type">int</span> *RightLine ,<span class="type">char</span> path)</span></span><br><span class="line">{</span><br><span class="line">    uint8 row,cloum;              <span class="comment">//行,列</span></span><br><span class="line">    uint8 flag_l=<span class="number">0</span>,flag_r=<span class="number">0</span>;    <span class="comment">//记录是否丢线flag，flag=0：丢线</span></span><br><span class="line">    uint8 num=<span class="number">0</span>;                <span class="comment">//记录中线连续丢失的次数</span></span><br><span class="line">    LostNum_LeftLine=<span class="number">0</span>;LostNum_RightLine=<span class="number">0</span>; <span class="comment">//把丢线的计数变量清零</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//开始扫线(从下往上,从中间往两边),为了扫线的严谨性,我们做BORDER_BIAS的误差处理，即扫线范围会小于图像大小</span></span><br><span class="line">    <span class="keyword">for</span>(row=MT9V03X_H<span class="number">-1</span>;row&gt;<span class="number">0</span>;row--) <span class="comment">//从下往上，遍历整幅图像</span></span><br><span class="line">    {</span><br><span class="line">        <span class="comment">//在赛道外，优先按path扫线方向寻找赛道</span></span><br><span class="line">        <span class="keyword">if</span>(BinaryImage[row][Mid]==IMAGE_BLACK)  <span class="comment">//扫线中点是黑色的（中点在赛道外）</span></span><br><span class="line">        {</span><br><span class="line">            num++;    <span class="comment">//中线连续丢失，+1</span></span><br><span class="line">            <span class="keyword">if</span>(path==<span class="string">'L'</span>)   <span class="comment">//默认向左扫线</span></span><br><span class="line">            {</span><br><span class="line">                <span class="comment">//先向左边扫线，寻找右边界点</span></span><br><span class="line">                <span class="keyword">for</span>(cloum=Mid;cloum-BORDER_BIAS&gt;<span class="number">0</span>;cloum--)    <span class="comment">//向左扫</span></span><br><span class="line">                {</span><br><span class="line">                    <span class="keyword">if</span>(BinaryImage[row][cloum]==IMAGE_WHITE &amp;&amp; BinaryImage[row][cloum-BORDER_BIAS]==IMAGE_WHITE)  <span class="comment">//找到白点（从赛道外扫到赛道内：黑-白）</span></span><br><span class="line">                    {</span><br><span class="line">                        RightLine[row]=cloum;    <span class="comment">//记录右边界点（向左找到的是右边界点）</span></span><br><span class="line">                        flag_r=<span class="number">1</span>;               <span class="comment">//flag做无丢线标记</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">                <span class="comment">//根据上面扫线的结果判断丢失的赛道是在左边还是右边从而决定继续向哪边扫线</span></span><br><span class="line">                <span class="keyword">if</span>(flag_r==<span class="number">1</span>)   <span class="comment">//找到了右边界（丢失的赛道在左边）</span></span><br><span class="line">                {</span><br><span class="line">                    <span class="comment">//继续向左寻找左边界</span></span><br><span class="line">                    <span class="keyword">for</span>(;cloum-BORDER_BIAS&gt;<span class="number">0</span>;cloum--)    <span class="comment">//继续向左扫</span></span><br><span class="line">                    {</span><br><span class="line">                        <span class="keyword">if</span>(BinaryImage[row][cloum]==IMAGE_BLACK &amp;&amp; BinaryImage[row][cloum-BORDER_BIAS]==IMAGE_BLACK)    <span class="comment">//找到黑点：（从赛道内扫到赛道外：白-黑）</span></span><br><span class="line">                        {</span><br><span class="line">                            LeftLine[row]=cloum;   <span class="comment">//记录左边界点</span></span><br><span class="line">                            flag_l=<span class="number">1</span>;              <span class="comment">//flag做无丢线标记</span></span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        }</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">else</span>            <span class="comment">//没有找到右边界（丢失的赛道在右边）</span></span><br><span class="line">                {</span><br><span class="line">                    <span class="keyword">for</span>(cloum=Mid;cloum+BORDER_BIAS&lt;MT9V03X_W<span class="number">-1</span>;cloum++)    <span class="comment">//向右扫</span></span><br><span class="line">                    {</span><br><span class="line">                        <span class="keyword">if</span>(BinaryImage[row][cloum]==IMAGE_WHITE &amp;&amp; BinaryImage[row][cloum+BORDER_BIAS]==IMAGE_WHITE)</span><br><span class="line">                        {</span><br><span class="line">                            LeftLine[row]=cloum;   <span class="comment">//记录左边界点（向右找到的是左边界点）</span></span><br><span class="line">                            flag_l=<span class="number">1</span>;              <span class="comment">//flag做无丢线标记</span></span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        }</span><br><span class="line">                    }</span><br><span class="line">                    <span class="keyword">if</span>(flag_l==<span class="number">1</span>)   <span class="comment">//找到了左边界（丢失的赛道在右边）</span></span><br><span class="line">                    {</span><br><span class="line">                        <span class="keyword">for</span>(;cloum+BORDER_BIAS&lt;MT9V03X_W<span class="number">-1</span>;cloum++) <span class="comment">//继续向右扫</span></span><br><span class="line">                        {</span><br><span class="line">                            <span class="keyword">if</span>(BinaryImage[row][cloum]==IMAGE_BLACK &amp;&amp; BinaryImage[row][cloum+BORDER_BIAS]==IMAGE_BLACK)</span><br><span class="line">                            {</span><br><span class="line">                                RightLine[row]=cloum;   <span class="comment">//记录右边界点</span></span><br><span class="line">                                flag_r=<span class="number">1</span>;               <span class="comment">//flag做无丢线标记</span></span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            }</span><br><span class="line">                        }</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(path==<span class="string">'R'</span>)  <span class="comment">//默认向右扫线</span></span><br><span class="line">            {</span><br><span class="line">                <span class="comment">//先向右边扫线，寻找左边界点</span></span><br><span class="line">                <span class="keyword">for</span>(cloum=Mid;cloum+BORDER_BIAS&lt;MT9V03X_W<span class="number">-1</span>;cloum++)    <span class="comment">//向右扫</span></span><br><span class="line">                {</span><br><span class="line">                    <span class="comment">//判断左边界点</span></span><br><span class="line">                    <span class="keyword">if</span>(BinaryImage[row][cloum]==IMAGE_WHITE &amp;&amp; BinaryImage[row][cloum+BORDER_BIAS]==IMAGE_WHITE)  <span class="comment">//找到白点（从赛道外扫到赛道内：黑-白）</span></span><br><span class="line">                    {</span><br><span class="line">                        LeftLine[row]=cloum;    <span class="comment">//记录左边界点（向右找到的是左边界点）</span></span><br><span class="line">                        flag_l=<span class="number">1</span>;               <span class="comment">//flag做无丢线标记</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">                <span class="comment">//根据上面扫线的结果判断丢失的赛道是在左边还是右边从而决定继续向哪边扫线</span></span><br><span class="line">                <span class="keyword">if</span>(flag_l==<span class="number">1</span>)   <span class="comment">//找到了左边界（丢失的赛道在右边）</span></span><br><span class="line">                {</span><br><span class="line">                    <span class="comment">//继续向右寻找右边界</span></span><br><span class="line">                    <span class="keyword">for</span>(;cloum+BORDER_BIAS&lt;MT9V03X_W<span class="number">-1</span>;cloum++) <span class="comment">//继续向右扫</span></span><br><span class="line">                    {</span><br><span class="line">                        <span class="comment">//判断右边界点</span></span><br><span class="line">                        <span class="keyword">if</span>(BinaryImage[row][cloum]==IMAGE_BLACK &amp;&amp; BinaryImage[row][cloum+BORDER_BIAS]==IMAGE_BLACK)    <span class="comment">//找到黑点（从赛道内扫到赛道外：白-黑）</span></span><br><span class="line">                        {</span><br><span class="line">                            RightLine[row]=cloum;   <span class="comment">//记录左边界点</span></span><br><span class="line">                            flag_r=<span class="number">1</span>;               <span class="comment">//flag做无丢线标记</span></span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        }</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">else</span>            <span class="comment">//没有找到左边界（丢失的赛道在左边）</span></span><br><span class="line">                {</span><br><span class="line">                    <span class="keyword">for</span>(cloum=Mid;cloum-BORDER_BIAS&gt;<span class="number">0</span>;cloum--)    <span class="comment">//向左扫</span></span><br><span class="line">                    {</span><br><span class="line">                        <span class="comment">//判断右边界点</span></span><br><span class="line">                        <span class="keyword">if</span>(BinaryImage[row][cloum]==IMAGE_WHITE &amp;&amp; BinaryImage[row][cloum-BORDER_BIAS]==IMAGE_WHITE)</span><br><span class="line">                        {</span><br><span class="line">                            RightLine[row]=cloum;   <span class="comment">//记录右边界点（向左找到的是右边界点）</span></span><br><span class="line">                            flag_r=<span class="number">1</span>;               <span class="comment">//flag做无丢线标记</span></span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        }</span><br><span class="line">                    }</span><br><span class="line">                    <span class="keyword">if</span>(flag_r==<span class="number">1</span>)   <span class="comment">//找到了右边界（丢失的赛道在左边）</span></span><br><span class="line">                    {</span><br><span class="line">                        <span class="comment">//继续向左寻找左边界</span></span><br><span class="line">                        <span class="keyword">for</span>(;cloum-BORDER_BIAS&gt;<span class="number">0</span>;cloum--)   <span class="comment">//继续向左扫</span></span><br><span class="line">                        {</span><br><span class="line">                            <span class="comment">//判断左边界点</span></span><br><span class="line">                            <span class="keyword">if</span>(BinaryImage[row][cloum]==IMAGE_BLACK &amp;&amp; BinaryImage[row][cloum-BORDER_BIAS]==IMAGE_BLACK)  <span class="comment">//判断右边界点</span></span><br><span class="line">                            {</span><br><span class="line">                                LeftLine[row]=cloum;    <span class="comment">//记录左边界点</span></span><br><span class="line">                                flag_l=<span class="number">1</span>;               <span class="comment">//flag做无丢线标记</span></span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            }</span><br><span class="line">                        }</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//在赛道中，正常扫线</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        {</span><br><span class="line">            num=<span class="number">0</span>;  <span class="comment">//打断中线连续丢失，=0</span></span><br><span class="line">            <span class="comment">//左边扫线</span></span><br><span class="line">            <span class="keyword">for</span>(cloum=Mid;cloum-BORDER_BIAS&gt;<span class="number">0</span>;cloum--)              <span class="comment">//向左扫</span></span><br><span class="line">            {</span><br><span class="line">                <span class="keyword">if</span>(BinaryImage[row][cloum]==IMAGE_BLACK &amp;&amp; BinaryImage[row][cloum-BORDER_BIAS]==IMAGE_BLACK)  <span class="comment">//判断左边界点（BORDER_BIAS防偶然因素）</span></span><br><span class="line">                {</span><br><span class="line">                    LeftLine[row]=cloum;    <span class="comment">//记录左边界点</span></span><br><span class="line">                    flag_l=<span class="number">1</span>;               <span class="comment">//flag做无丢线标记</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">//右边扫线</span></span><br><span class="line">            <span class="keyword">for</span>(cloum=Mid;cloum+BORDER_BIAS&lt;MT9V03X_W<span class="number">-1</span>;cloum++)    <span class="comment">//向右扫</span></span><br><span class="line">            {</span><br><span class="line">                <span class="keyword">if</span>(BinaryImage[row][cloum]==IMAGE_BLACK &amp;&amp; BinaryImage[row][cloum+BORDER_BIAS]==IMAGE_BLACK)  <span class="comment">//判断右边界点（BORDER_BIAS防偶然因素）</span></span><br><span class="line">                {</span><br><span class="line">                    RightLine[row]=cloum;   <span class="comment">//记录右边界点</span></span><br><span class="line">                    flag_r=<span class="number">1</span>;               <span class="comment">//flag做无丢线标记</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//1.29晚上重新写的数据处理</span></span><br><span class="line">        <span class="keyword">if</span>(flag_l==<span class="number">0</span>)   <span class="comment">//左边界丢线</span></span><br><span class="line">        {</span><br><span class="line">            LeftLine[row]=<span class="number">0</span>;            <span class="comment">//左边界点等于图像的左边界</span></span><br><span class="line">            LostNum_LeftLine++;         <span class="comment">//左丢线数+1</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(flag_r==<span class="number">0</span>)   <span class="comment">//右边界丢线</span></span><br><span class="line">        {</span><br><span class="line">            RightLine[row]=MT9V03X_W<span class="number">-1</span>; <span class="comment">//右边界点等于图像的右边界</span></span><br><span class="line">            LostNum_RightLine++;        <span class="comment">//右丢线数+1</span></span><br><span class="line">        }</span><br><span class="line">        CentreLine[row]=(LeftLine[row]+RightLine[row])/<span class="number">2</span>;   <span class="comment">//计算中线点</span></span><br><span class="line">        <span class="comment">//为下一次扫线做准备</span></span><br><span class="line">        Mid=CentreLine[row];    <span class="comment">//以上一次的中线值为下一次扫线的中间点</span></span><br><span class="line">        flag_l=<span class="number">0</span>;               <span class="comment">//左边界丢线flag置0</span></span><br><span class="line">        flag_r=<span class="number">0</span>;               <span class="comment">//右边界丢线flag置0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        //LCD绘制图像</span></span><br><span class="line"><span class="comment">//        lcd_drawpoint(LeftLine[row],row,GREEN);</span></span><br><span class="line"><span class="comment">//        lcd_drawpoint(CentreLine[row],row,RED);</span></span><br><span class="line"><span class="comment">//        lcd_drawpoint(RightLine[row],row,BLUE);</span></span><br><span class="line"><span class="comment">//        systick_delay_ms(STM0,50);</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> ** 函数功能: 根据左右边界线来得到下拐点（十字、三岔、环岛的判断会用上）</span></span><br><span class="line"><span class="comment"> ** 参    数: int starline:     起始行</span></span><br><span class="line"><span class="comment"> **           int endline:      结束行</span></span><br><span class="line"><span class="comment"> **           int *LeftLine：     左线数组</span></span><br><span class="line"><span class="comment"> **           int *RightLine：   右线数组</span></span><br><span class="line"><span class="comment"> **           Point *InflectionL: 左边拐点</span></span><br><span class="line"><span class="comment"> **           Point *InflectionR: 右边拐点</span></span><br><span class="line"><span class="comment"> ** 返 回 值: 无</span></span><br><span class="line"><span class="comment"> ** 说    明: - 用指针带入进来函数，最后得到的点可以两点确定直线进行补线</span></span><br><span class="line"><span class="comment"> **           - 由于图像原点在左上角，所以起始行是大于结束行，左右线数组从下往上遍历</span></span><br><span class="line"><span class="comment"> ** 作    者: LJF</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">GetDownInflection</span><span class="params">(<span class="type">int</span> startline,<span class="type">int</span> endline,<span class="type">int</span> *LeftLine,<span class="type">int</span> *RightLine,Point *InflectionL,Point *InflectionR)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    InflectionL-&gt;X=<span class="number">0</span>;InflectionL-&gt;Y=<span class="number">0</span>;InflectionR-&gt;X=<span class="number">0</span>;InflectionR-&gt;Y=<span class="number">0</span>;<span class="comment">//左右拐点置零</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i=startline;i&gt;endline;i--)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">//遍历左线，求出先变小大后变小的点，多加三个点的判断是为了误判，左边丢线为0</span></span><br><span class="line">        <span class="comment">/*注意：这里如果判断条件是和相邻的1,3的值对比的话，会区间太小从而如果有相等的列数存在的话，会影响判断，所以需要改大比较的区间*/</span></span><br><span class="line">        <span class="comment">//加了个判断InflectionL-&gt;Y==0是为了从下往上遍历，找到了之后就不再继续往上找了，这样遍历时候的截距图片就不用刚刚好了</span></span><br><span class="line">        <span class="comment">//2022年5月27日：加多一层条件，即：比&gt;=相邻的点，随后再取筛选它是不是直线：大于比较远的点</span></span><br><span class="line">        <span class="keyword">if</span>(InflectionL-&gt;Y==<span class="number">0</span> &amp;&amp; LeftLine[i]&gt;=LeftLine[i<span class="number">-1</span>] &amp;&amp; LeftLine[i]&gt;=LeftLine[i<span class="number">-3</span>] &amp;&amp; LeftLine[i]&gt;=LeftLine[i+<span class="number">1</span>] &amp;&amp; LeftLine[i]&gt;=LeftLine[i+<span class="number">3</span>])</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">if</span>(LeftLine[i]&gt;LeftLine[i<span class="number">-5</span>] &amp;&amp; LeftLine[i]&gt;LeftLine[i<span class="number">-7</span>] &amp;&amp; LeftLine[i]&gt;LeftLine[i+<span class="number">5</span>] &amp;&amp; LeftLine[i]&gt;LeftLine[i+<span class="number">7</span>])</span><br><span class="line">            {</span><br><span class="line">                InflectionL-&gt;X=LeftLine[i];<span class="comment">//存入拐点的（x,y）坐标</span></span><br><span class="line">                InflectionL-&gt;Y=i;</span><br><span class="line">                <span class="comment">/*debug*/</span></span><br><span class="line"><span class="comment">//                lcd_showint32(0,6,InflectionL-&gt;X,3);</span></span><br><span class="line"><span class="comment">//                systick_delay_ms(STM0, 1000);</span></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历右线，求出列数最小的点就是右边的拐点，右边线丢线为MT9V03X_W-1</span></span><br><span class="line">        <span class="comment">//加了个判断InflectionR-&gt;Y==0是为了从下往上遍历，找到了之后就不再继续往上找了，这样遍历时候的截距图片就不用刚刚好了</span></span><br><span class="line">        <span class="keyword">if</span>(InflectionR-&gt;Y==<span class="number">0</span> &amp;&amp; RightLine[i]&lt;=RightLine[i<span class="number">-1</span>] &amp;&amp; RightLine[i]&lt;=RightLine[i<span class="number">-3</span>] &amp;&amp; RightLine[i]&lt;=RightLine[i+<span class="number">1</span>] &amp;&amp; RightLine[i]&lt;=RightLine[i+<span class="number">3</span>])</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">if</span>(RightLine[i]&lt;RightLine[i<span class="number">-5</span>] &amp;&amp; RightLine[i]&lt;RightLine[i<span class="number">-7</span>] &amp;&amp; RightLine[i]&lt;RightLine[i+<span class="number">5</span>] &amp;&amp; RightLine[i]&lt;RightLine[i+<span class="number">7</span>])</span><br><span class="line">            {</span><br><span class="line">                InflectionR-&gt;X=RightLine[i];<span class="comment">//存入拐点的（x,y）坐标</span></span><br><span class="line">                InflectionR-&gt;Y=i;</span><br><span class="line">               <span class="comment">/*打印被判断为拐点的列坐标，用于调试*/</span></span><br><span class="line"><span class="comment">//                lcd_showint32(TFT_X_MAX-50,6,InflectionR-&gt;X,3);</span></span><br><span class="line"><span class="comment">//                systick_delay_ms(STM0, 1000);</span></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*打印被判断为拐点的列坐标，用于调试*/</span></span><br><span class="line"><span class="comment">//        lcd_drawpoint(RightLine[i],i,RED);</span></span><br><span class="line"><span class="comment">//        lcd_showint32(0,0,LeftLine[i],3);</span></span><br><span class="line"><span class="comment">//        systick_delay_ms(STM0, 800);</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UPINFLECTION_DOWM_MIN_THRESHOLD  15  <span class="comment">//上拐点列坐标与下面行数的差值最小阈值</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UPINFLECTION_UP_MAX_THRESHOLD  5  <span class="comment">//上拐点列坐标与上面行数的差值最大阈值</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UPINFLECTION_COMPARE_INTERVAL 3 <span class="comment">//上拐点两点之间比较间隔</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/************************************************************************</span></span><br><span class="line"><span class="comment"> ** 函数功能: 根据左右边界得到上拐点</span></span><br><span class="line"><span class="comment"> ** 参    数: char Choose：选择遍历左线还是右线</span></span><br><span class="line"><span class="comment"> **           int startline：起始行</span></span><br><span class="line"><span class="comment"> **           int endline：结束行</span></span><br><span class="line"><span class="comment"> **           Point *UpInflection：上拐点</span></span><br><span class="line"><span class="comment"> ** 返 回 值: 无</span></span><br><span class="line"><span class="comment"> ** 说    明: 起始行要小于结束行，从上往下遍历左右线</span></span><br><span class="line"><span class="comment"> ** 作    者: LJF</span></span><br><span class="line"><span class="comment"> ***********************************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">GetUpInflection</span><span class="params">(<span class="type">char</span> Choose,<span class="type">int</span> startline,<span class="type">int</span> endline,Point *UpInflection)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> row=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">switch</span>(Choose)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'L'</span>:</span><br><span class="line">        {</span><br><span class="line">            <span class="comment">//从上往下遍历</span></span><br><span class="line">            <span class="keyword">for</span> (row = startline; row &lt; endline; row++)</span><br><span class="line">            {</span><br><span class="line">                <span class="comment">//下三行的列坐标-这行列坐标大于阈值，不用ABS是为了速度更快</span></span><br><span class="line">                <span class="keyword">if</span> (LeftLine[row] - LeftLine[row+UPINFLECTION_COMPARE_INTERVAL] &gt;= UPINFLECTION_DOWM_MIN_THRESHOLD</span><br><span class="line">                 &amp;&amp; LeftLine[row - UPINFLECTION_COMPARE_INTERVAL] - LeftLine[row + UPINFLECTION_COMPARE_INTERVAL] &gt;= UPINFLECTION_DOWM_MIN_THRESHOLD</span><br><span class="line">                 &amp;&amp; LeftLine[row<span class="number">-1</span>]-LeftLine[row]&lt;=UPINFLECTION_UP_MAX_THRESHOLD)</span><br><span class="line">                {</span><br><span class="line">                    UpInflection-&gt;X = LeftLine[row]; UpInflection-&gt;Y = row;</span><br><span class="line">                    <span class="comment">/**************debug***********/</span></span><br><span class="line"><span class="comment">//                    lcd_drawpoint(UpInflection-&gt;X,UpInflection-&gt;Y,PURPLE);</span></span><br><span class="line"><span class="comment">//                    lcd_showint32(TFT_X_MAX-50,0,UpInflection-&gt;X,3);</span></span><br><span class="line"><span class="comment">//                    lcd_showint32(TFT_X_MAX-50,1,UpInflection-&gt;Y,3);</span></span><br><span class="line"><span class="comment">//                    systick_delay_ms(STM0, 800);</span></span><br><span class="line">                    <span class="comment">/*****************************/</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                }</span><br><span class="line">                <span class="comment">/**************debug***********/</span></span><br><span class="line"><span class="comment">//                lcd_showint32(0,0,LeftLine[row],3);</span></span><br><span class="line"><span class="comment">//                lcd_showint32(0,1,LeftLine[row+UPINFLECTION_COMPARE_INTERVAL],3);</span></span><br><span class="line"><span class="comment">//                systick_delay_ms(STM0, 800);</span></span><br><span class="line">                <span class="comment">/*****************************/</span></span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'R'</span>:</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">for</span>(row = startline; row &lt; endline; row++)</span><br><span class="line">            {</span><br><span class="line">                <span class="comment">//这行列坐标-下三行的列坐标大于阈值，不用ABS是为了速度更快</span></span><br><span class="line">                <span class="keyword">if</span> (RightLine[row+UPINFLECTION_COMPARE_INTERVAL] - RightLine[row] &gt;= UPINFLECTION_DOWM_MIN_THRESHOLD</span><br><span class="line">                 &amp;&amp; RightLine[row + UPINFLECTION_COMPARE_INTERVAL] - RightLine[row - UPINFLECTION_COMPARE_INTERVAL] &gt;= UPINFLECTION_DOWM_MIN_THRESHOLD</span><br><span class="line">                 &amp;&amp; RightLine[row]-RightLine[row<span class="number">-1</span>]&lt;=UPINFLECTION_UP_MAX_THRESHOLD)</span><br><span class="line">                {</span><br><span class="line">                    UpInflection-&gt;X=RightLine[row];UpInflection-&gt;Y=row;</span><br><span class="line">                   <span class="comment">/**************debug***********/</span></span><br><span class="line"><span class="comment">//                   lcd_drawpoint(UpInflection-&gt;X,UpInflection-&gt;Y,PURPLE);</span></span><br><span class="line"><span class="comment">//                   lcd_showint32(TFT_X_MAX-50,0,UpInflection-&gt;X,3);</span></span><br><span class="line"><span class="comment">//                   lcd_showint32(TFT_X_MAX-50,1,UpInflection-&gt;Y,3);</span></span><br><span class="line"><span class="comment">//                   systick_delay_ms(STM0, 800);</span></span><br><span class="line">                   <span class="comment">/*****************************/</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">default</span>:<span class="keyword">break</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">/************************************************************************</span></span><br><span class="line"><span class="comment"> ** 函数功能: 根据图像黑白跳变寻找上直角拐点</span></span><br><span class="line"><span class="comment"> ** 参    数: char Choose：选择是左上还是右上</span></span><br><span class="line"><span class="comment"> **           Point DowmInflection：基准点</span></span><br><span class="line"><span class="comment"> **           Point *UpInflection：找到的上拐点</span></span><br><span class="line"><span class="comment"> **           int RowThr:遍历图像行的阈值（找跳变点到哪里停下）</span></span><br><span class="line"><span class="comment"> **           int CloumnThr:遍历图像列的阈值</span></span><br><span class="line"><span class="comment"> ** 返 回 值: 无</span></span><br><span class="line"><span class="comment"> ** 说    明: 起始行要小于结束行，从上往下遍历左右线</span></span><br><span class="line"><span class="comment"> ** 作    者: LJF</span></span><br><span class="line"><span class="comment"> ***********************************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">GetRightangleUPInflection</span><span class="params">(<span class="type">char</span> Choose,Point DowmInflection,Point *UpInflection,<span class="type">int</span> ROWTHR,<span class="type">int</span> CLOUMNTHR)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> row=<span class="number">0</span>,cloumn=<span class="number">0</span>;<span class="comment">//起始行,列</span></span><br><span class="line">    UpInflection-&gt;X=<span class="number">0</span>;UpInflection-&gt;Y=<span class="number">0</span>;<span class="comment">//左上拐点置零</span></span><br><span class="line">    <span class="comment">//从下往上找白跳黑</span></span><br><span class="line">    <span class="keyword">for</span>(row=DowmInflection.Y;row&gt;ROWTHR;row--)</span><br><span class="line">    {</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> FINE_RIGHT_ANGLE_INFLECTION_DEBUG</span></span><br><span class="line">        lcd_drawpoint(DowmInflection.X, row, PURPLE);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        <span class="keyword">if</span>(BinaryImage[row][DowmInflection.X]==IMAGE_WHITE&amp;&amp;BinaryImage[row<span class="number">-1</span>][DowmInflection.X]==IMAGE_BLACK)</span><br><span class="line">        {</span><br><span class="line">            row=row<span class="number">-3</span>;<span class="comment">//多往上面跳点</span></span><br><span class="line">            <span class="keyword">switch</span>(Choose)</span><br><span class="line">            {</span><br><span class="line">               <span class="keyword">case</span> <span class="string">'L'</span>:</span><br><span class="line">               {</span><br><span class="line">                   <span class="comment">//左往右找到黑跳白</span></span><br><span class="line">                   <span class="keyword">for</span>(cloumn=DowmInflection.X;cloumn&lt;CLOUMNTHR;cloumn++)</span><br><span class="line">                   {</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> FINE_RIGHT_ANGLE_INFLECTION_DEBUG</span></span><br><span class="line">                       lcd_drawpoint(cloumn, row, PURPLE);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">                       <span class="keyword">if</span>(BinaryImage[row][cloumn]==IMAGE_BLACK&amp;&amp;BinaryImage[row][cloumn+<span class="number">1</span>]==IMAGE_WHITE)</span><br><span class="line">                       {</span><br><span class="line">                           UpInflection-&gt;X=cloumn;UpInflection-&gt;Y=row;</span><br><span class="line">                           <span class="keyword">break</span>;</span><br><span class="line">                       }</span><br><span class="line">                   }</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               }</span><br><span class="line">               <span class="keyword">case</span> <span class="string">'R'</span>:</span><br><span class="line">               {</span><br><span class="line">                   <span class="comment">//右往左找到黑跳白</span></span><br><span class="line">                   <span class="keyword">for</span>(cloumn=DowmInflection.X;cloumn&gt;CLOUMNTHR;cloumn--)</span><br><span class="line">                   {</span><br><span class="line">                       <span class="keyword">if</span>(BinaryImage[row][cloumn]==IMAGE_BLACK&amp;&amp;BinaryImage[row][cloumn<span class="number">-1</span>]==IMAGE_WHITE)</span><br><span class="line">                       {</span><br><span class="line">                           UpInflection-&gt;X=cloumn;UpInflection-&gt;Y=row;</span><br><span class="line">                           <span class="keyword">break</span>;</span><br><span class="line">                       }</span><br><span class="line">                   }</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               }</span><br><span class="line">               <span class="keyword">default</span>:<span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">break</span>;<span class="comment">//跳出行循环,没必要继续行循环下去</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">/*---------------------------------------------------------------</span></span><br><span class="line"><span class="comment"> 【函    数】Bin_Image_Filter</span></span><br><span class="line"><span class="comment"> 【功    能】过滤噪点</span></span><br><span class="line"><span class="comment"> 【参    数】无</span></span><br><span class="line"><span class="comment"> 【返 回 值】无</span></span><br><span class="line"><span class="comment"> 【注意事项】</span></span><br><span class="line"><span class="comment"> ----------------------------------------------------------------*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Bin_Image_Filter</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> nr=<span class="number">1</span>; nr &lt; MT9V03X_H<span class="number">-1</span>; nr++)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> nc=<span class="number">1</span>; nc &lt; MT9V03X_W<span class="number">-1</span>; nc++)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">if</span> ((BinaryImage[nr][nc] == IMAGE_BLACK)</span><br><span class="line">                    &amp;&amp;(BinaryImage[nr<span class="number">-1</span>][nc]+BinaryImage[nr+<span class="number">1</span>][nc]+BinaryImage[nr][nc+<span class="number">1</span>]+BinaryImage[nr][nc<span class="number">-1</span>]&gt;<span class="number">510</span>))</span><br><span class="line">            {</span><br><span class="line">                BinaryImage[nr][nc] = IMAGE_WHITE;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((BinaryImage[nr][nc] == IMAGE_WHITE)</span><br><span class="line">                    &amp;&amp; (BinaryImage[nr<span class="number">-1</span>][nc]+BinaryImage[nr+<span class="number">1</span>][nc]+BinaryImage[nr][nc+<span class="number">1</span>]+BinaryImage[nr][nc<span class="number">-1</span>]&lt;<span class="number">510</span>))</span><br><span class="line">            {</span><br><span class="line">                BinaryImage[nr][nc] = IMAGE_BLACK;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/************************************************************************</span></span><br><span class="line"><span class="comment"> ** 函数功能: 测量赛道宽度函数</span></span><br><span class="line"><span class="comment"> ** 参    数: int startline:要测量的起始行</span></span><br><span class="line"><span class="comment"> **           int endline:要测量的结束行</span></span><br><span class="line"><span class="comment"> ** 返 回 值: 无</span></span><br><span class="line"><span class="comment"> ** 说    明: 用于赛前测试使用，赛道宽度可以给拐弯的时候单边巡线</span></span><br><span class="line"><span class="comment"> ** 作    者: LJF</span></span><br><span class="line"><span class="comment"> ***********************************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MeasureWidth</span><span class="params">(<span class="type">int</span> startline,<span class="type">int</span> endline)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> row=<span class="number">0</span>,width=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(row=startline;row&gt;endline;row--)</span><br><span class="line">    {</span><br><span class="line">        width=RightLine[row]-LeftLine[row];</span><br><span class="line"><span class="comment">//        printf("%d\r\n",width);//测到赛道宽度与行的函数关系为y=135-(119-nowline)*1.1</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> ** 函数功能: 扫线提取左中右三线的坐标：车库专属</span></span><br><span class="line"><span class="comment"> ** 参    数: *LeftLine：左线数组</span></span><br><span class="line"><span class="comment"> **           *CentreLine：中线数组</span></span><br><span class="line"><span class="comment"> **           *RightLine：右线数组</span></span><br><span class="line"><span class="comment"> **           path：默认扫线方向</span></span><br><span class="line"><span class="comment"> ** 返 回 值: 无</span></span><br><span class="line"><span class="comment"> ** 作    者: WBN</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">GetImagBasic_Garage</span><span class="params">(<span class="type">int</span> *LeftLine, <span class="type">int</span> *CentreLine, <span class="type">int</span> *RightLine ,<span class="type">char</span> path)</span></span><br><span class="line">{</span><br><span class="line">    uint8 row,cloum;              <span class="comment">//行,列</span></span><br><span class="line">    uint8 flag_l=<span class="number">0</span>,flag_r=<span class="number">0</span>;    <span class="comment">//记录是否丢线flag，flag=0：丢线</span></span><br><span class="line">    uint8 num=<span class="number">0</span>;                <span class="comment">//记录中线连续丢失的次数</span></span><br><span class="line">    LostNum_LeftLine=<span class="number">0</span>;LostNum_RightLine=<span class="number">0</span>; <span class="comment">//把丢线的计数变量清零</span></span><br><span class="line">    uint8 black_num=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//开始扫线(从下往上,从中间往两边),为了扫线的严谨性,我们做BORDER_BIAS的误差处理，即扫线范围会小于图像大小</span></span><br><span class="line">    <span class="keyword">for</span>(row=MT9V03X_H<span class="number">-1</span>;row&gt;<span class="number">0</span>;row--) <span class="comment">//从下往上，遍历整幅图像</span></span><br><span class="line">    {</span><br><span class="line">        <span class="comment">//在赛道外，优先按path扫线方向寻找赛道</span></span><br><span class="line">        <span class="keyword">if</span>(BinaryImage[row][Mid]==IMAGE_BLACK)  <span class="comment">//扫线中点是黑色的（中点在赛道外）</span></span><br><span class="line">        {</span><br><span class="line">            num++;    <span class="comment">//中线连续丢失，+1</span></span><br><span class="line">            <span class="keyword">if</span>(path==<span class="string">'L'</span>)   <span class="comment">//默认向左扫线</span></span><br><span class="line">            {</span><br><span class="line">                <span class="comment">//先向左边扫线，寻找右边界点</span></span><br><span class="line">                <span class="keyword">for</span>(cloum=Mid;cloum-BORDER_BIAS&gt;<span class="number">0</span>;cloum--)    <span class="comment">//向左扫</span></span><br><span class="line">                {</span><br><span class="line">                    <span class="keyword">if</span>(BinaryImage[row][cloum]==IMAGE_WHITE &amp;&amp; BinaryImage[row][cloum-BORDER_BIAS]==IMAGE_WHITE)  <span class="comment">//找到白点（从赛道外扫到赛道内：黑-白）</span></span><br><span class="line">                    {</span><br><span class="line">                        RightLine[row]=cloum;    <span class="comment">//记录右边界点（向左找到的是右边界点）</span></span><br><span class="line">                        flag_r=<span class="number">1</span>;               <span class="comment">//flag做无丢线标记</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">                <span class="comment">//根据上面扫线的结果判断丢失的赛道是在左边还是右边从而决定继续向哪边扫线</span></span><br><span class="line">                <span class="keyword">if</span>(flag_r==<span class="number">1</span>)   <span class="comment">//找到了右边界（丢失的赛道在左边）</span></span><br><span class="line">                {</span><br><span class="line">                    black_num=<span class="number">0</span>;</span><br><span class="line">                    <span class="comment">//继续向左寻找左边界</span></span><br><span class="line">                    <span class="keyword">for</span>(;cloum-BORDER_BIAS&gt;<span class="number">0</span>;cloum--)    <span class="comment">//继续向左扫</span></span><br><span class="line">                    {</span><br><span class="line">                        <span class="keyword">if</span>(BinaryImage[row][cloum]==IMAGE_BLACK)    <span class="comment">//找到黑点：（从赛道内扫到赛道外：白-黑）</span></span><br><span class="line">                        {</span><br><span class="line">                            black_num++;</span><br><span class="line">                        }</span><br><span class="line">                        <span class="keyword">else</span>    <span class="comment">//保证连续扫点</span></span><br><span class="line">                        {</span><br><span class="line">                            black_num=<span class="number">0</span>;</span><br><span class="line">                        }</span><br><span class="line">                        <span class="keyword">if</span>(black_num&gt;=BASIC_GARAGE)   <span class="comment">//连续扫到十个黑点</span></span><br><span class="line">                        {</span><br><span class="line">                            LeftLine[row]=cloum+BASIC_GARAGE;   <span class="comment">//记录左边界点</span></span><br><span class="line">                            flag_l=<span class="number">1</span>;              <span class="comment">//flag做无丢线标记</span></span><br><span class="line">                            black_num=<span class="number">0</span>;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        }</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">else</span>            <span class="comment">//没有找到右边界（丢失的赛道在右边）</span></span><br><span class="line">                {</span><br><span class="line">                    <span class="keyword">for</span>(cloum=Mid;cloum+BORDER_BIAS&lt;MT9V03X_W<span class="number">-1</span>;cloum++)    <span class="comment">//向右扫</span></span><br><span class="line">                    {</span><br><span class="line">                        <span class="keyword">if</span>(BinaryImage[row][cloum]==IMAGE_WHITE &amp;&amp; BinaryImage[row][cloum+BORDER_BIAS]==IMAGE_WHITE)</span><br><span class="line">                        {</span><br><span class="line">                            LeftLine[row]=cloum;   <span class="comment">//记录左边界点（向右找到的是左边界点）</span></span><br><span class="line">                            flag_l=<span class="number">1</span>;              <span class="comment">//flag做无丢线标记</span></span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        }</span><br><span class="line">                    }</span><br><span class="line">                    <span class="keyword">if</span>(flag_l==<span class="number">1</span>)   <span class="comment">//找到了左边界（丢失的赛道在右边）</span></span><br><span class="line">                    {</span><br><span class="line">                        black_num=<span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">for</span>(;cloum+BORDER_BIAS&lt;MT9V03X_W<span class="number">-1</span>;cloum++) <span class="comment">//继续向右扫</span></span><br><span class="line">                        {</span><br><span class="line">                            <span class="keyword">if</span>(BinaryImage[row][cloum]==IMAGE_BLACK)</span><br><span class="line">                            {</span><br><span class="line">                                black_num++;</span><br><span class="line">                            }</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                            {</span><br><span class="line">                                black_num=<span class="number">0</span>;</span><br><span class="line">                            }</span><br><span class="line">                            <span class="keyword">if</span>(black_num&gt;=BASIC_GARAGE)   <span class="comment">//连续扫到十个黑点</span></span><br><span class="line">                            {</span><br><span class="line">                                RightLine[row]=cloum-BASIC_GARAGE;   <span class="comment">//记录右边界点</span></span><br><span class="line">                                flag_r=<span class="number">1</span>;               <span class="comment">//flag做无丢线标记</span></span><br><span class="line">                                black_num=<span class="number">0</span>;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            }</span><br><span class="line">                        }</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(path==<span class="string">'R'</span>)  <span class="comment">//默认向右扫线</span></span><br><span class="line">            {</span><br><span class="line">                <span class="comment">//先向右边扫线，寻找左边界点</span></span><br><span class="line">                <span class="keyword">for</span>(cloum=Mid;cloum+BORDER_BIAS&lt;MT9V03X_W<span class="number">-1</span>;cloum++)    <span class="comment">//向右扫</span></span><br><span class="line">                {</span><br><span class="line">                    <span class="comment">//判断左边界点</span></span><br><span class="line">                    <span class="keyword">if</span>(BinaryImage[row][cloum]==IMAGE_WHITE &amp;&amp; BinaryImage[row][cloum+BORDER_BIAS]==IMAGE_WHITE)  <span class="comment">//找到白点（从赛道外扫到赛道内：黑-白）</span></span><br><span class="line">                    {</span><br><span class="line">                        LeftLine[row]=cloum;    <span class="comment">//记录左边界点（向右找到的是左边界点）</span></span><br><span class="line">                        flag_l=<span class="number">1</span>;               <span class="comment">//flag做无丢线标记</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">                <span class="comment">//根据上面扫线的结果判断丢失的赛道是在左边还是右边从而决定继续向哪边扫线</span></span><br><span class="line">                <span class="keyword">if</span>(flag_l==<span class="number">1</span>)   <span class="comment">//找到了左边界（丢失的赛道在右边）</span></span><br><span class="line">                {</span><br><span class="line">                    black_num=<span class="number">0</span>;</span><br><span class="line">                    <span class="comment">//继续向右寻找右边界</span></span><br><span class="line">                    <span class="keyword">for</span>(;cloum+BORDER_BIAS&lt;MT9V03X_W<span class="number">-1</span>;cloum++) <span class="comment">//继续向右扫</span></span><br><span class="line">                    {</span><br><span class="line">                        <span class="comment">//判断右边界点</span></span><br><span class="line">                        <span class="keyword">if</span>(BinaryImage[row][cloum]==IMAGE_BLACK)    <span class="comment">//找到黑点（从赛道内扫到赛道外：白-黑）</span></span><br><span class="line">                        {</span><br><span class="line">                            black_num++;</span><br><span class="line">                        }</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                        {</span><br><span class="line">                            black_num=<span class="number">0</span>;</span><br><span class="line">                        }</span><br><span class="line">                        <span class="keyword">if</span>(black_num&gt;=BASIC_GARAGE)</span><br><span class="line">                        {</span><br><span class="line">                            RightLine[row]=cloum-BASIC_GARAGE;   <span class="comment">//记录左边界点</span></span><br><span class="line">                            flag_r=<span class="number">1</span>;               <span class="comment">//flag做无丢线标记</span></span><br><span class="line">                            black_num=<span class="number">0</span>;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        }</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">else</span>            <span class="comment">//没有找到左边界（丢失的赛道在左边）</span></span><br><span class="line">                {</span><br><span class="line">                    <span class="keyword">for</span>(cloum=Mid;cloum-BORDER_BIAS&gt;<span class="number">0</span>;cloum--)    <span class="comment">//向左扫</span></span><br><span class="line">                    {</span><br><span class="line">                        <span class="comment">//判断右边界点</span></span><br><span class="line">                        <span class="keyword">if</span>(BinaryImage[row][cloum]==IMAGE_WHITE &amp;&amp; BinaryImage[row][cloum-BORDER_BIAS]==IMAGE_WHITE)</span><br><span class="line">                        {</span><br><span class="line">                            RightLine[row]=cloum;   <span class="comment">//记录右边界点（向左找到的是右边界点）</span></span><br><span class="line">                            flag_r=<span class="number">1</span>;               <span class="comment">//flag做无丢线标记</span></span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        }</span><br><span class="line">                    }</span><br><span class="line">                    <span class="keyword">if</span>(flag_r==<span class="number">1</span>)   <span class="comment">//找到了右边界（丢失的赛道在左边）</span></span><br><span class="line">                    {</span><br><span class="line">                        black_num=<span class="number">0</span>;</span><br><span class="line">                        <span class="comment">//继续向左寻找左边界</span></span><br><span class="line">                        <span class="keyword">for</span>(;cloum-BORDER_BIAS&gt;<span class="number">0</span>;cloum--)   <span class="comment">//继续向左扫</span></span><br><span class="line">                        {</span><br><span class="line">                            <span class="comment">//判断左边界点</span></span><br><span class="line">                            <span class="keyword">if</span>(BinaryImage[row][cloum]==IMAGE_BLACK)  <span class="comment">//判断右边界点</span></span><br><span class="line">                            {</span><br><span class="line">                                black_num++;</span><br><span class="line">                            }</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                            {</span><br><span class="line">                                black_num=<span class="number">0</span>;</span><br><span class="line">                            }</span><br><span class="line">                            <span class="keyword">if</span>(black_num&gt;=BASIC_GARAGE)</span><br><span class="line">                            {</span><br><span class="line">                                LeftLine[row]=cloum-BASIC_GARAGE;    <span class="comment">//记录左边界点</span></span><br><span class="line">                                flag_l=<span class="number">1</span>;               <span class="comment">//flag做无丢线标记</span></span><br><span class="line">                                black_num=<span class="number">0</span>;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            }</span><br><span class="line">                        }</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//在赛道中，正常扫线</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        {</span><br><span class="line">            num=<span class="number">0</span>;  <span class="comment">//打断中线连续丢失，=0</span></span><br><span class="line">            <span class="comment">//左边扫线</span></span><br><span class="line">            black_num=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(cloum=Mid;cloum-BORDER_BIAS&gt;<span class="number">0</span>;cloum--)              <span class="comment">//向左扫</span></span><br><span class="line">            {</span><br><span class="line">                <span class="keyword">if</span>(BinaryImage[row][cloum]==IMAGE_BLACK)  <span class="comment">//判断左边界点（BORDER_BIAS防偶然因素）</span></span><br><span class="line">                {</span><br><span class="line">                    black_num++;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                {</span><br><span class="line">                    black_num=<span class="number">0</span>;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">if</span>(black_num&gt;=BASIC_GARAGE)</span><br><span class="line">                {</span><br><span class="line">                    LeftLine[row]=cloum+BASIC_GARAGE;    <span class="comment">//记录左边界点</span></span><br><span class="line">                    flag_l=<span class="number">1</span>;               <span class="comment">//flag做无丢线标记</span></span><br><span class="line">                    black_num=<span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">//右边扫线</span></span><br><span class="line">            black_num=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(cloum=Mid;cloum+BORDER_BIAS&lt;MT9V03X_W<span class="number">-1</span>;cloum++)    <span class="comment">//向右扫</span></span><br><span class="line">            {</span><br><span class="line">                <span class="keyword">if</span>(BinaryImage[row][cloum]==IMAGE_BLACK)  <span class="comment">//判断右边界点（BORDER_BIAS防偶然因素）</span></span><br><span class="line">                {</span><br><span class="line">                    black_num++;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                {</span><br><span class="line">                    black_num=<span class="number">0</span>;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">if</span>(black_num&gt;=BASIC_GARAGE)</span><br><span class="line">                {</span><br><span class="line">                    RightLine[row]=cloum-BASIC_GARAGE;   <span class="comment">//记录右边界点</span></span><br><span class="line">                    flag_r=<span class="number">1</span>;               <span class="comment">//flag做无丢线标记</span></span><br><span class="line">                    black_num=<span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(flag_l==<span class="number">0</span>)   <span class="comment">//左边界丢线</span></span><br><span class="line">        {</span><br><span class="line">            LeftLine[row]=<span class="number">0</span>;            <span class="comment">//左边界点等于图像的左边界</span></span><br><span class="line">            LostNum_LeftLine++;         <span class="comment">//左丢线数+1</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(flag_r==<span class="number">0</span>)   <span class="comment">//右边界丢线</span></span><br><span class="line">        {</span><br><span class="line">            RightLine[row]=MT9V03X_W<span class="number">-1</span>; <span class="comment">//右边界点等于图像的右边界</span></span><br><span class="line">            LostNum_RightLine++;        <span class="comment">//右丢线数+1</span></span><br><span class="line">        }</span><br><span class="line">        CentreLine[row]=(LeftLine[row]+RightLine[row])/<span class="number">2</span>;   <span class="comment">//计算中线点</span></span><br><span class="line">        <span class="comment">//为下一次扫线做准备</span></span><br><span class="line">        Mid=CentreLine[row];    <span class="comment">//以上一次的中线值为下一次扫线的中间点</span></span><br><span class="line">        flag_l=<span class="number">0</span>;               <span class="comment">//左边界丢线flag置0</span></span><br><span class="line">        flag_r=<span class="number">0</span>;               <span class="comment">//右边界丢线flag置0</span></span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2024/06/09/SRTP_UWB_Positioning/" rel="prev" title="SRTP_Project_UWB_Technology">
                SRTP_Project_UWB_Technology <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
      <div id="sidebar-dimmer"></div>
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/header.png"
                alt="" />
            
              <p class="site-author-name" itemprop="name"></p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/%7C%7C%20archive">
              
                  <span class="site-state-item-count">6</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">2</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/baikal2411" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:3024161302@qq.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      
        <div class="back-to-top">
          <i class="fa fa-arrow-up"></i>
          
            <span id="scrollpercent"><span>0</span>%</span>
          
        </div>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Liyuan Zha</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">站内总字数&#58;</span>
    
    <span title="站内总字数">17.6k</span>
  
</div>









        







        
      </div>
    </footer>

    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src=""></script>
  


  

  

</body>
</html>
